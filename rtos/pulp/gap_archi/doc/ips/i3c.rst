Input file: fe/ips/lnt_i3c_master/docs/I3C_reference.xlsx

Register map
^^^^^^^^^^^^


Overview
""""""""

.. table:: 

    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |                             Name                              |Offset|Width|                                                                      Description                                                                      |
    +===============================================================+======+=====+=======================================================================================================================================================+
    |:ref:`Mst_Cntl_En_Reg<i3c_Mst_Cntl_En_Reg>`                    |     0|   32|I3C Master control.                                                                                                                                    |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`CMD_Tr_Req_Reg_1<i3c_CMD_Tr_Req_Reg_1>`                  |     4|   32|Data length or Data byte value to be sent along with the CCC or HDR command.                                                                           |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`CMD_Tr_Req_Reg_2<i3c_CMD_Tr_Req_Reg_2>`                  |     8|   32|Command type, Transaction ID, CCC code and slave address. Writing to this register is considered as Doorbell for the master to initiate the transfer.  |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Resp_Reg<i3c_Resp_Reg>`                                  |    16|   32|Success or failure of the command, Transaction ID and the remaining data.                                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`IBI_Resp_Reg<i3c_IBI_Resp_Reg>`                          |    20|   32|In-Band interrupt status, timestamping information present, dynamic address of the slave or Hot Join request.                                          |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`IBI_Data_Reg<i3c_IBI_Data_Reg>`                          |    24|   32|Data received from the slave during the IBI process.                                                                                                   |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Data_RX_FIFO_Reg<i3c_Data_RX_FIFO_Reg>`                  |    28|   32|Received data FIFO (Data_RX_FIFO).                                                                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Data_TX_FIFO_Reg<i3c_Data_TX_FIFO_Reg>`                  |    32|   32|Sending data FIFO (Data_TX_FIFO).                                                                                                                      |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`IRQ_STATUS_Reg<i3c_IRQ_STATUS_Reg>`                      |    48|   32|Status of the event happened during the transfer.                                                                                                      |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TCAS_TIMER_Reg<i3c_TCAS_TIMER_Reg>`                      |    64|   32|Timing for Clock after Start condition (TCAS) is the time (in Number of Reference clocks) after the start condition after which the SCL pin can go low.|
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TLOW_OD_TIMER_Reg<i3c_TLOW_OD_TIMER_Reg>`                |    68|   32|Low period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go high.                                                 |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`THIGH_OD_TIMER_Reg<i3c_THIGH_OD_TIMER_Reg>`              |    72|   32|High period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go low.                                                 |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TLOW_PP_TIMER_Reg<i3c_TLOW_PP_TIMER_Reg>`                |    76|   32|Low period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go high.                                                  |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`THIGH_PP_TIMER_Reg<i3c_THIGH_PP_TIMER_Reg>`              |    80|   32|High period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go low.                                                  |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TDS_TIMER_Reg<i3c_TDS_TIMER_Reg>`                        |    84|   32|SDA data setup time during both Open-Drain/Push-Pull mode (in Number of Reference clock).                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`THD_PP_TIMER_Reg<i3c_THD_PP_TIMER_Reg>`                  |    88|   32|SDA data hold time during the Push-Pull mode (in Number of Reference clock).                                                                           |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TCBP_TIMER_Reg<i3c_TCBP_TIMER_Reg>`                      |    92|   32|Clock time before Stop condition.                                                                                                                      |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TCBSR_TIMER_Reg<i3c_TCBSR_TIMER_Reg>`                    |    96|   32|Clock time before Repeated start condition.                                                                                                            |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`THD_DDR_TIMER_Reg<i3c_THD_DDR_TIMER_Reg>`                |   100|   32|SDA data hold time during the Push-Pull mode (in Number of Reference clock) in DDR Data rate.                                                          |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`BUS_FREE_TIMER_Reg<i3c_BUS_FREE_TIMER_Reg>`              |   104|   32|Bus free time between the Stop condition and the next start condition (in Number of Reference clock).                                                  |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`BUS_AVAIL_TIMER_Reg<i3c_BUS_AVAIL_TIMER_Reg>`            |   108|   32|Time to keep the SDA and SCL pin to High (in Number of Reference clock).                                                                               |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TIDLE_TIMER_Reg<i3c_TIDLE_TIMER_Reg>`                    |   112|   32|Extended duration of the bus free condition after the Stop condition (in Number of Reference clock) to enable the device to drive the Hot Join request.|
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TSCO_TIMER_Reg<i3c_TSCO_TIMER_Reg>`                      |   116|   32|Maximum time the slave needs to drive the bus during the ACK/read data after the clock change.                                                         |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TSU_STA_TIMER_Reg<i3c_TSU_STA_TIMER_Reg>`                |   144|   32|SDA data setup time during both Open-Drain (in Number of Reference clock) for a Repeated Start.                                                        |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`THD_STA_TIMER_Reg<i3c_THD_STA_TIMER_Reg>`                |   148|   32|SDA data hold time during the Open Drain mode (in Number of Reference clock).                                                                          |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TLOW_TIMER_Reg<i3c_TLOW_TIMER_Reg>`                      |   152|   32|Low period of SCL pin in Open Drain mode during Legacy I2c Mode (in Number of Reference clock) after the timer reached the SCL pin can go high.        |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`THIGH_TIMER_Reg<i3c_THIGH_TIMER_Reg>`                    |   156|   32|High period of SCL pin in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SCL pin can go low.         |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TVD_DATA_TIMER_Reg<i3c_TVD_DATA_TIMER_Reg>`              |   160|   32|Data hold time in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SDA pin can change its value.       |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`TSU_STOP_TIMER_Reg<i3c_TSU_STOP_TIMER_Reg>`              |   168|   32|SDA data setup time during Open-Drain (in Number of Reference clock) for Stop condition.                                                               |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg0<i3c_Device_Addr_Table_Reg0>`      |   256|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave0.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg1<i3c_Device_Addr_Table_Reg1>`      |   260|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave1.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg2<i3c_Device_Addr_Table_Reg2>`      |   264|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave2.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg3<i3c_Device_Addr_Table_Reg3>`      |   268|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave3.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg4<i3c_Device_Addr_Table_Reg4>`      |   272|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave4.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg5<i3c_Device_Addr_Table_Reg5>`      |   276|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave5.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg6<i3c_Device_Addr_Table_Reg6>`      |   280|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave6.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg7<i3c_Device_Addr_Table_Reg7>`      |   284|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave7.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg8<i3c_Device_Addr_Table_Reg8>`      |   288|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave8.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg9<i3c_Device_Addr_Table_Reg9>`      |   292|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave9.                                                              |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg10<i3c_Device_Addr_Table_Reg10>`    |   296|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave10.                                                             |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Addr_Table_Reg11<i3c_Device_Addr_Table_Reg11>`    |   300|   32|Device type, IBI handling and Dynamic address to be set and Static address of the slave11.                                                             |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_0<i3c_Device_Char_Table_Reg0_0>`  |   512|  128|BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_0<i3c_Device_Char_Table_Reg1_0>`  |   516|  128|BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_0<i3c_Device_Char_Table_Reg2_0>`  |   520|  128|BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_0<i3c_Device_Char_Table_Reg3_0>`  |   524|  128|BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_1<i3c_Device_Char_Table_Reg0_1>`  |   528|  128|BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_1<i3c_Device_Char_Table_Reg1_1>`  |   532|  128|BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_1<i3c_Device_Char_Table_Reg2_1>`  |   536|  128|BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_1<i3c_Device_Char_Table_Reg3_1>`  |   540|  128|BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_2<i3c_Device_Char_Table_Reg0_2>`  |   544|  128|BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_2<i3c_Device_Char_Table_Reg1_2>`  |   548|  128|BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_2<i3c_Device_Char_Table_Reg2_2>`  |   552|  128|BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_2<i3c_Device_Char_Table_Reg3_2>`  |   556|  128|BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_3<i3c_Device_Char_Table_Reg0_3>`  |   560|  128|BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_3<i3c_Device_Char_Table_Reg1_3>`  |   564|  128|BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_3<i3c_Device_Char_Table_Reg2_3>`  |   568|  128|BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_3<i3c_Device_Char_Table_Reg3_3>`  |   572|  128|BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_4<i3c_Device_Char_Table_Reg0_4>`  |   576|  128|BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_4<i3c_Device_Char_Table_Reg1_4>`  |   580|  128|BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_4<i3c_Device_Char_Table_Reg2_4>`  |   584|  128|BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_4<i3c_Device_Char_Table_Reg3_4>`  |   588|  128|BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_5<i3c_Device_Char_Table_Reg0_5>`  |   592|  128|BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_5<i3c_Device_Char_Table_Reg1_5>`  |   596|  128|BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_5<i3c_Device_Char_Table_Reg2_5>`  |   600|  128|BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_5<i3c_Device_Char_Table_Reg3_5>`  |   604|  128|BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_6<i3c_Device_Char_Table_Reg0_6>`  |   608|  128|BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_6<i3c_Device_Char_Table_Reg1_6>`  |   612|  128|BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_6<i3c_Device_Char_Table_Reg2_6>`  |   616|  128|BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_6<i3c_Device_Char_Table_Reg3_6>`  |   620|  128|BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_7<i3c_Device_Char_Table_Reg0_7>`  |   624|  128|BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_7<i3c_Device_Char_Table_Reg1_7>`  |   628|  128|BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_7<i3c_Device_Char_Table_Reg2_7>`  |   632|  128|BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_7<i3c_Device_Char_Table_Reg3_7>`  |   636|  128|BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_8<i3c_Device_Char_Table_Reg0_8>`  |   640|  128|BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_8<i3c_Device_Char_Table_Reg1_8>`  |   644|  128|BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_8<i3c_Device_Char_Table_Reg2_8>`  |   648|  128|BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_8<i3c_Device_Char_Table_Reg3_8>`  |   652|  128|BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_9<i3c_Device_Char_Table_Reg0_9>`  |   656|  128|BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_9<i3c_Device_Char_Table_Reg1_9>`  |   660|  128|BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_9<i3c_Device_Char_Table_Reg2_9>`  |   664|  128|BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_9<i3c_Device_Char_Table_Reg3_9>`  |   668|  128|BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.                                                                     |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_10<i3c_Device_Char_Table_Reg0_10>`|   672|  128|BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.                                                                    |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_10<i3c_Device_Char_Table_Reg1_10>`|   676|  128|BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.                                                                    |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_10<i3c_Device_Char_Table_Reg2_10>`|   680|  128|BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.                                                                    |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_10<i3c_Device_Char_Table_Reg3_10>`|   684|  128|BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.                                                                    |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg0_11<i3c_Device_Char_Table_Reg0_11>`|   688|  128|BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.                                                                    |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg1_11<i3c_Device_Char_Table_Reg1_11>`|   692|  128|BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.                                                                    |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg2_11<i3c_Device_Char_Table_Reg2_11>`|   696|  128|BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.                                                                    |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+
    |:ref:`Device_Char_Table_Reg3_11<i3c_Device_Char_Table_Reg3_11>`|   700|  128|BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.                                                                    |
    +---------------------------------------------------------------+------+-----+-------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // I3C Master control.
                #define I3C_MST_CNTL_EN_REG_OFFSET               0x0
        
                // Data length or Data byte value to be sent along with the CCC or HDR command.
                #define I3C_CMD_TR_REQ_REG_1_OFFSET              0x4
        
                // Command type, Transaction ID, CCC code and slave address. Writing to this register is considered as Doorbell for the master to initiate the transfer.
                #define I3C_CMD_TR_REQ_REG_2_OFFSET              0x8
        
                // Success or failure of the command, Transaction ID and the remaining data.
                #define I3C_RESP_REG_OFFSET                      0x10
        
                // In-Band interrupt status, timestamping information present, dynamic address of the slave or Hot Join request.
                #define I3C_IBI_RESP_REG_OFFSET                  0x14
        
                // Data received from the slave during the IBI process.
                #define I3C_IBI_DATA_REG_OFFSET                  0x18
        
                // Received data FIFO (Data_RX_FIFO).
                #define I3C_DATA_RX_FIFO_REG_OFFSET              0x1c
        
                // Sending data FIFO (Data_TX_FIFO).
                #define I3C_DATA_TX_FIFO_REG_OFFSET              0x20
        
                // Status of the event happened during the transfer.
                #define I3C_IRQ_STATUS_REG_OFFSET                0x30
        
                // Timing for Clock after Start condition (TCAS) is the time (in Number of Reference clocks) after the start condition after which the SCL pin can go low.
                #define I3C_TCAS_TIMER_REG_OFFSET                0x40
        
                // Low period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go high.
                #define I3C_TLOW_OD_TIMER_REG_OFFSET             0x44
        
                // High period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go low.
                #define I3C_THIGH_OD_TIMER_REG_OFFSET            0x48
        
                // Low period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go high.
                #define I3C_TLOW_PP_TIMER_REG_OFFSET             0x4c
        
                // High period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go low.
                #define I3C_THIGH_PP_TIMER_REG_OFFSET            0x50
        
                // SDA data setup time during both Open-Drain/Push-Pull mode (in Number of Reference clock).
                #define I3C_TDS_TIMER_REG_OFFSET                 0x54
        
                // SDA data hold time during the Push-Pull mode (in Number of Reference clock).
                #define I3C_THD_PP_TIMER_REG_OFFSET              0x58
        
                // Clock time before Stop condition.
                #define I3C_TCBP_TIMER_REG_OFFSET                0x5c
        
                // Clock time before Repeated start condition.
                #define I3C_TCBSR_TIMER_REG_OFFSET               0x60
        
                // SDA data hold time during the Push-Pull mode (in Number of Reference clock) in DDR Data rate.
                #define I3C_THD_DDR_TIMER_REG_OFFSET             0x64
        
                // Bus free time between the Stop condition and the next start condition (in Number of Reference clock).
                #define I3C_BUS_FREE_TIMER_REG_OFFSET            0x68
        
                // Time to keep the SDA and SCL pin to High (in Number of Reference clock).
                #define I3C_BUS_AVAIL_TIMER_REG_OFFSET           0x6c
        
                // Extended duration of the bus free condition after the Stop condition (in Number of Reference clock) to enable the device to drive the Hot Join request.
                #define I3C_TIDLE_TIMER_REG_OFFSET               0x70
        
                // Maximum time the slave needs to drive the bus during the ACK/read data after the clock change.
                #define I3C_TSCO_TIMER_REG_OFFSET                0x74
        
                // SDA data setup time during both Open-Drain (in Number of Reference clock) for a Repeated Start.
                #define I3C_TSU_STA_TIMER_REG_OFFSET             0x90
        
                // SDA data hold time during the Open Drain mode (in Number of Reference clock).
                #define I3C_THD_STA_TIMER_REG_OFFSET             0x94
        
                // Low period of SCL pin in Open Drain mode during Legacy I2c Mode (in Number of Reference clock) after the timer reached the SCL pin can go high.
                #define I3C_TLOW_TIMER_REG_OFFSET                0x98
        
                // High period of SCL pin in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SCL pin can go low.
                #define I3C_THIGH_TIMER_REG_OFFSET               0x9c
        
                // Data hold time in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SDA pin can change its value.
                #define I3C_TVD_DATA_TIMER_REG_OFFSET            0xa0
        
                // SDA data setup time during Open-Drain (in Number of Reference clock) for Stop condition.
                #define I3C_TSU_STOP_TIMER_REG_OFFSET            0xa8
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave0.
                #define I3C_DEVICE_ADDR_TABLE_REG0_OFFSET        0x100
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave1.
                #define I3C_DEVICE_ADDR_TABLE_REG1_OFFSET        0x104
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave2.
                #define I3C_DEVICE_ADDR_TABLE_REG2_OFFSET        0x108
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave3.
                #define I3C_DEVICE_ADDR_TABLE_REG3_OFFSET        0x10c
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave4.
                #define I3C_DEVICE_ADDR_TABLE_REG4_OFFSET        0x110
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave5.
                #define I3C_DEVICE_ADDR_TABLE_REG5_OFFSET        0x114
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave6.
                #define I3C_DEVICE_ADDR_TABLE_REG6_OFFSET        0x118
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave7.
                #define I3C_DEVICE_ADDR_TABLE_REG7_OFFSET        0x11c
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave8.
                #define I3C_DEVICE_ADDR_TABLE_REG8_OFFSET        0x120
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave9.
                #define I3C_DEVICE_ADDR_TABLE_REG9_OFFSET        0x124
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave10.
                #define I3C_DEVICE_ADDR_TABLE_REG10_OFFSET       0x128
        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave11.
                #define I3C_DEVICE_ADDR_TABLE_REG11_OFFSET       0x12c
        
                // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_0_OFFSET      0x200
        
                // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_0_OFFSET      0x204
        
                // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_0_OFFSET      0x208
        
                // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_0_OFFSET      0x20c
        
                // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_1_OFFSET      0x210
        
                // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_1_OFFSET      0x214
        
                // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_1_OFFSET      0x218
        
                // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_1_OFFSET      0x21c
        
                // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_2_OFFSET      0x220
        
                // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_2_OFFSET      0x224
        
                // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_2_OFFSET      0x228
        
                // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_2_OFFSET      0x22c
        
                // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_3_OFFSET      0x230
        
                // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_3_OFFSET      0x234
        
                // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_3_OFFSET      0x238
        
                // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_3_OFFSET      0x23c
        
                // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_4_OFFSET      0x240
        
                // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_4_OFFSET      0x244
        
                // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_4_OFFSET      0x248
        
                // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_4_OFFSET      0x24c
        
                // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_5_OFFSET      0x250
        
                // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_5_OFFSET      0x254
        
                // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_5_OFFSET      0x258
        
                // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_5_OFFSET      0x25c
        
                // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_6_OFFSET      0x260
        
                // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_6_OFFSET      0x264
        
                // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_6_OFFSET      0x268
        
                // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_6_OFFSET      0x26c
        
                // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_7_OFFSET      0x270
        
                // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_7_OFFSET      0x274
        
                // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_7_OFFSET      0x278
        
                // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_7_OFFSET      0x27c
        
                // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_8_OFFSET      0x280
        
                // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_8_OFFSET      0x284
        
                // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_8_OFFSET      0x288
        
                // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_8_OFFSET      0x28c
        
                // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_9_OFFSET      0x290
        
                // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_9_OFFSET      0x294
        
                // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_9_OFFSET      0x298
        
                // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_9_OFFSET      0x29c
        
                // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_10_OFFSET     0x2a0
        
                // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_10_OFFSET     0x2a4
        
                // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_10_OFFSET     0x2a8
        
                // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_10_OFFSET     0x2ac
        
                // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_11_OFFSET     0x2b0
        
                // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_11_OFFSET     0x2b4
        
                // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_11_OFFSET     0x2b8
        
                // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_11_OFFSET     0x2bc

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_mst_cntl_en_reg_get(uint32_t base);
        static inline void i3c_mst_cntl_en_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_cmd_tr_req_reg_1_get(uint32_t base);
        static inline void i3c_cmd_tr_req_reg_1_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_cmd_tr_req_reg_2_get(uint32_t base);
        static inline void i3c_cmd_tr_req_reg_2_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_resp_reg_get(uint32_t base);
        static inline void i3c_resp_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_ibi_resp_reg_get(uint32_t base);
        static inline void i3c_ibi_resp_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_ibi_data_reg_get(uint32_t base);
        static inline void i3c_ibi_data_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_data_rx_fifo_reg_get(uint32_t base);
        static inline void i3c_data_rx_fifo_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_data_tx_fifo_reg_get(uint32_t base);
        static inline void i3c_data_tx_fifo_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_irq_status_reg_get(uint32_t base);
        static inline void i3c_irq_status_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tcas_timer_reg_get(uint32_t base);
        static inline void i3c_tcas_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tlow_od_timer_reg_get(uint32_t base);
        static inline void i3c_tlow_od_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_thigh_od_timer_reg_get(uint32_t base);
        static inline void i3c_thigh_od_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tlow_pp_timer_reg_get(uint32_t base);
        static inline void i3c_tlow_pp_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_thigh_pp_timer_reg_get(uint32_t base);
        static inline void i3c_thigh_pp_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tds_timer_reg_get(uint32_t base);
        static inline void i3c_tds_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_thd_pp_timer_reg_get(uint32_t base);
        static inline void i3c_thd_pp_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tcbp_timer_reg_get(uint32_t base);
        static inline void i3c_tcbp_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tcbsr_timer_reg_get(uint32_t base);
        static inline void i3c_tcbsr_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_thd_ddr_timer_reg_get(uint32_t base);
        static inline void i3c_thd_ddr_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_bus_free_timer_reg_get(uint32_t base);
        static inline void i3c_bus_free_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_bus_avail_timer_reg_get(uint32_t base);
        static inline void i3c_bus_avail_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tidle_timer_reg_get(uint32_t base);
        static inline void i3c_tidle_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tsco_timer_reg_get(uint32_t base);
        static inline void i3c_tsco_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tsu_sta_timer_reg_get(uint32_t base);
        static inline void i3c_tsu_sta_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_thd_sta_timer_reg_get(uint32_t base);
        static inline void i3c_thd_sta_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tlow_timer_reg_get(uint32_t base);
        static inline void i3c_tlow_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_thigh_timer_reg_get(uint32_t base);
        static inline void i3c_thigh_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tvd_data_timer_reg_get(uint32_t base);
        static inline void i3c_tvd_data_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_tsu_stop_timer_reg_get(uint32_t base);
        static inline void i3c_tsu_stop_timer_reg_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg0_get(uint32_t base);
        static inline void i3c_device_addr_table_reg0_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg1_get(uint32_t base);
        static inline void i3c_device_addr_table_reg1_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg2_get(uint32_t base);
        static inline void i3c_device_addr_table_reg2_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg3_get(uint32_t base);
        static inline void i3c_device_addr_table_reg3_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg4_get(uint32_t base);
        static inline void i3c_device_addr_table_reg4_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg5_get(uint32_t base);
        static inline void i3c_device_addr_table_reg5_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg6_get(uint32_t base);
        static inline void i3c_device_addr_table_reg6_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg7_get(uint32_t base);
        static inline void i3c_device_addr_table_reg7_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg8_get(uint32_t base);
        static inline void i3c_device_addr_table_reg8_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg9_get(uint32_t base);
        static inline void i3c_device_addr_table_reg9_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg10_get(uint32_t base);
        static inline void i3c_device_addr_table_reg10_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_addr_table_reg11_get(uint32_t base);
        static inline void i3c_device_addr_table_reg11_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_0_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_0_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_0_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_0_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_0_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_0_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_0_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_0_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_1_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_1_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_1_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_1_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_1_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_1_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_1_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_1_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_2_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_2_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_2_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_2_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_2_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_2_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_2_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_2_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_3_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_3_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_3_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_3_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_3_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_3_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_3_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_3_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_4_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_4_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_4_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_4_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_4_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_4_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_4_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_4_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_5_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_5_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_5_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_5_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_5_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_5_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_5_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_5_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_6_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_6_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_6_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_6_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_6_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_6_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_6_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_6_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_7_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_7_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_7_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_7_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_7_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_7_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_7_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_7_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_8_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_8_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_8_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_8_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_8_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_8_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_8_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_8_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_9_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_9_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_9_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_9_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_9_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_9_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_9_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_9_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_10_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_10_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_10_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_10_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_10_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_10_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_10_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_10_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg0_11_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_11_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg1_11_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_11_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg2_11_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_11_set(uint32_t base, uint32_t value);

        static inline uint32_t i3c_device_char_table_reg3_11_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_11_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Master control enable : To enable the I3C Master controller for any transfers. -1b0 : I3C Master is disabled -1b1 : I3C master is enabled (access: R/W)
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_BIT                    0
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_WIDTH                  1
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_MASK                   0x1
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_RESET                  0x0
        
        // Master Reset enable (Soft reset) : To enable the I3C Master controller to issue Soft reset during any transfers. Soft reset will be applied after the completion of ACK/NACK state. -1b0 : I3C Master reset is disabled -1b1 : I3C master reset is enabled (access: R/W)
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_BIT                        1
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_WIDTH                      1
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_MASK                       0x2
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_RESET                      0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_BIT                           2
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_WIDTH                         30
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_MASK                          0xfffffffc
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_RESET                         0x0
        
        // Data length or Data byte value. This register contains Data length or Data byte value depending on the type of command being initiated. (access: W)
        #define I3C_CMD_TR_REQ_REG_1_DATA_BIT                                0
        #define I3C_CMD_TR_REQ_REG_1_DATA_WIDTH                              32
        #define I3C_CMD_TR_REQ_REG_1_DATA_MASK                               0xffffffff
        #define I3C_CMD_TR_REQ_REG_1_DATA_RESET                              0x0
        
        // Command request. This register contains information about the command type, Transaction ID, slave address and the type of CCC or HDR to be initiated. (access: W)
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_BIT                             0
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_WIDTH                           32
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_MASK                            0xffffffff
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_RESET                           0x0
        
        // Response register. Contains values of the success/failure of the command, transaction ID of the completed command & remaining data (for write transfer) or received data length (for read transfer) or number of remaining slaves (for dynamic address command). (access: R)
        #define I3C_RESP_REG_RESP_REG_BIT                                    0
        #define I3C_RESP_REG_RESP_REG_WIDTH                                  32
        #define I3C_RESP_REG_RESP_REG_MASK                                   0xffffffff
        #define I3C_RESP_REG_RESP_REG_RESET                                  0x0
        
        // IBI Data length. Number of bytes in the IBI requests received. (access: R)
        #define I3C_IBI_RESP_REG_DATA_LEN_BIT                                0
        #define I3C_IBI_RESP_REG_DATA_LEN_WIDTH                              8
        #define I3C_IBI_RESP_REG_DATA_LEN_MASK                               0xff
        #define I3C_IBI_RESP_REG_DATA_LEN_RESET                              0x0
        
        // IBI received ID. Contains slave address for IBI. Contains Hot Join ID for the Hot-Join IBI (access: R)
        #define I3C_IBI_RESP_REG_IBI_ID_BIT                                  8
        #define I3C_IBI_RESP_REG_IBI_ID_WIDTH                                8
        #define I3C_IBI_RESP_REG_IBI_ID_MASK                                 0xff00
        #define I3C_IBI_RESP_REG_IBI_ID_RESET                                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_IBI_RESP_REG_RESERVED_0_BIT                              16
        #define I3C_IBI_RESP_REG_RESERVED_0_WIDTH                            9
        #define I3C_IBI_RESP_REG_RESERVED_0_MASK                             0x1ff0000
        #define I3C_IBI_RESP_REG_RESERVED_0_RESET                            0x0
        
        // IBI timestamp present for IBI : -1b1 : IBI is timestamped -1b0 : IBI is not timestamped (access: R)
        #define I3C_IBI_RESP_REG_TS_PRESENT_BIT                              25
        #define I3C_IBI_RESP_REG_TS_PRESENT_WIDTH                            1
        #define I3C_IBI_RESP_REG_TS_PRESENT_MASK                             0x2000000
        #define I3C_IBI_RESP_REG_TS_PRESENT_RESET                            0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_IBI_RESP_REG_RESERVED_5_BIT                              26
        #define I3C_IBI_RESP_REG_RESERVED_5_WIDTH                            5
        #define I3C_IBI_RESP_REG_RESERVED_5_MASK                             0x7c000000
        #define I3C_IBI_RESP_REG_RESERVED_5_RESET                            0x0
        
        // IBI status. Indicates how the IBI is handled : -1b0 : Indicates IBI is handled with ACK -1b1 : Indicates IBI is handled with NACK (access: R)
        #define I3C_IBI_RESP_REG_IBI_STS_BIT                                 31
        #define I3C_IBI_RESP_REG_IBI_STS_WIDTH                               1
        #define I3C_IBI_RESP_REG_IBI_STS_MASK                                0x80000000
        #define I3C_IBI_RESP_REG_IBI_STS_RESET                               0x0
        
        // IBI Data. Data received during the IBI process is stored in FIFO and is sent out to the Software using this register. (access: R)
        #define I3C_IBI_DATA_REG_IBI_DATA_BIT                                0
        #define I3C_IBI_DATA_REG_IBI_DATA_WIDTH                              32
        #define I3C_IBI_DATA_REG_IBI_DATA_MASK                               0xffffffff
        #define I3C_IBI_DATA_REG_IBI_DATA_RESET                              0x0
        
        // All the Data received from the slave is stored in FIFO. On request by the software, the FIFO read and the values are provided. (access: R)
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_BIT                             0
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_WIDTH                           32
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_MASK                            0xffffffff
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_RESET                           0x0
        
        // Write data to be sent from the Master to the slave. Software writes this register for sending the write data to the slave. (access: W)
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_BIT                             0
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_WIDTH                           32
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_MASK                            0xffffffff
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_RESET                           0x0
        
        // Indicates the response completion is done. (access: R)
        #define I3C_IRQ_STATUS_REG_RESP_DONE_BIT                             0
        #define I3C_IRQ_STATUS_REG_RESP_DONE_WIDTH                           1
        #define I3C_IRQ_STATUS_REG_RESP_DONE_MASK                            0x1
        #define I3C_IRQ_STATUS_REG_RESP_DONE_RESET                           0x0
        
        // Indicates the Data Tx FIFO is full. (access: R)
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_BIT                     1
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_WIDTH                   1
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_MASK                    0x2
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_RESET                   0x0
        
        // Indicates the Data Tx FIFO is empty. (access: R)
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_BIT                    2
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_WIDTH                  1
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_MASK                   0x4
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_RESET                  0x0
        
        // Indicates the command transfer request FIFO Full. (access: R)
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_BIT                     3
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_WIDTH                   1
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_MASK                    0x8
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_RESET                   0x0
        
        // Indicates the Data Rx FIFO Full. (access: R)
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_BIT                     4
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_WIDTH                   1
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_MASK                    0x10
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_RESET                   0x0
        
        // Indicates the response completion FIFO is full. (access: R)
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_BIT                            5
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_WIDTH                          1
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_MASK                           0x20
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_RESET                          0x0
        
        // Indicates the IBI request is received from slave. (access: R)
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_BIT                     6
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_WIDTH                   1
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_MASK                    0x40
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_RESET                   0x0
        
        // Indicates the IBI payload is full. (access: R)
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_BIT                 7
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_WIDTH               1
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_MASK                0x80
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_RESET               0x0
        
        // Indicates the Master controller issued soft reset. (access: R)
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_BIT                        8
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_WIDTH                      1
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_MASK                       0x100
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_RESET                      0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_IRQ_STATUS_REG_RESERVED_0_BIT                            9
        #define I3C_IRQ_STATUS_REG_RESERVED_0_WIDTH                          23
        #define I3C_IRQ_STATUS_REG_RESERVED_0_MASK                           0xfffffe00
        #define I3C_IRQ_STATUS_REG_RESERVED_0_RESET                          0x0
        
        // Timing of the SCL pin to go low after the start condition (Number of ref_clk). As per specification, Min time value is 38.4ns. For 100MHz ref clock, total 4 clock periods are required. So, the value of the register is 0x3. (access: R/W)
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_BIT                            0
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_WIDTH                          32
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_MASK                           0xffffffff
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_RESET                          0x3
        
        // Low period of the SCL clock pin (Number of ref_clk). As per specification, Min time value is 200ns + fall time of SDA signal. For 100MHz ref clock, total 24 clock periods are required. So, the value of the register is 0x23. (access: R/W)
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_BIT                      0
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_WIDTH                    5
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_MASK                     0x1f
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_RESET                    0x23
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_BIT                         5
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_WIDTH                       27
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_MASK                        0xffffffe0
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_RESET                       0x0
        
        // High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods is allowed. So, the value of the register is 0x2. (access: R/W)
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_BIT                    0
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_WIDTH                  5
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_MASK                   0x1f
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_RESET                  0x2
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_BIT                        5
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_WIDTH                      27
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_MASK                       0xffffffe0
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_RESET                      0x0
        
        // Low period of the SCL clock pin (Number of ref_clk) in Push pull mode. As per specification, Min time value is 24ns. For 100MHz ref clock, total 3 clock periods are required. So, the value of the register is 0x3. (access: R/W)
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_BIT                      0
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_WIDTH                    5
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_MASK                     0x1f
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_RESET                    0x3
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_BIT                         5
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_WIDTH                       27
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_MASK                        0xffffffe0
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_RESET                       0x0
        
        // High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods are required. So, the value of the register is 0x2. (access: R/W)
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_BIT                    0
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_WIDTH                  5
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_MASK                   0x1f
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_RESET                  0x2
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_BIT                        5
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_WIDTH                      27
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_MASK                       0xffffffe0
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_RESET                      0x0
        
        // SDA Set up time (Number of ref_clk). As per specification, Min time value is 3ns. For 100MHz ref clock, Max. of total 1 clock period is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_TDS_TIMER_REG_TDS_TIMER_BIT                              0
        #define I3C_TDS_TIMER_REG_TDS_TIMER_WIDTH                            3
        #define I3C_TDS_TIMER_REG_TDS_TIMER_MASK                             0x7
        #define I3C_TDS_TIMER_REG_TDS_TIMER_RESET                            0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TDS_TIMER_REG_RESERVED_0_BIT                             3
        #define I3C_TDS_TIMER_REG_RESERVED_0_WIDTH                           29
        #define I3C_TDS_TIMER_REG_RESERVED_0_MASK                            0xfffffff8
        #define I3C_TDS_TIMER_REG_RESERVED_0_RESET                           0x0
        
        // SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_BIT                        0
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_WIDTH                      3
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_MASK                       0x7
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_RESET                      0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_BIT                          3
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_WIDTH                        29
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_MASK                         0xfffffff8
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_RESET                        0x0
        
        // To signal STOP condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_BIT                            0
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_WIDTH                          5
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_MASK                           0x1f
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_RESET                          0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TCBP_TIMER_REG_RESERVED_0_BIT                            5
        #define I3C_TCBP_TIMER_REG_RESERVED_0_WIDTH                          27
        #define I3C_TCBP_TIMER_REG_RESERVED_0_MASK                           0xffffffe0
        #define I3C_TCBP_TIMER_REG_RESERVED_0_RESET                          0x0
        
        // To signal Repeated start condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_BIT                          0
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_WIDTH                        3
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_MASK                         0x7
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_RESET                        0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_BIT                           3
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_WIDTH                         29
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_MASK                          0xfffffff8
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_RESET                         0x0
        
        // SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_BIT                      0
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_WIDTH                    3
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_MASK                     0x7
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_RESET                    0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_BIT                         3
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_WIDTH                       29
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_MASK                        0xfffffff8
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_RESET                       0x0
        
        // Bus free time after the STOP condition and the Start condition. As per specification, Min. value of this period is 1us. (access: R/W)
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_BIT                    0
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_WIDTH                  32
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_MASK                   0xffffffff
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_RESET                  0x200
        
        // Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1us. (access: R/W)
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_BIT                  0
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_WIDTH                32
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_MASK                 0xffffffff
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_RESET                0x200
        
        // Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1ms. (access: R/W)
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_BIT                          0
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_WIDTH                        32
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_MASK                         0xffffffff
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_RESET                        0x200
        
        // Maximum time for the slave to release bus after the clock change. As per specification, Max. value is 12ns. (access: R/W)
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_BIT                            0
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_WIDTH                          3
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_MASK                           0x7
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_RESET                          0x2
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TSCO_TIMER_REG_RESERVED_0_BIT                            3
        #define I3C_TSCO_TIMER_REG_RESERVED_0_WIDTH                          29
        #define I3C_TSCO_TIMER_REG_RESERVED_0_MASK                           0xfffffff8
        #define I3C_TSCO_TIMER_REG_RESERVED_0_RESET                          0x0
        
        // SDA Set up time (Number of ref_clk) for a Repeated Start during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_BIT                      0
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_WIDTH                    9
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_MASK                     0x1ff
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_RESET                    0x46
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_BIT                         9
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_WIDTH                       23
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_MASK                        0xfffffe00
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_RESET                       0x0
        
        // SDA Hold time (Number of ref_clk) after Start/Repeated Start. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_BIT                      0
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_WIDTH                    9
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_MASK                     0x1ff
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_RESET                    0x46
        
        // Low period of the SCL clock pin (Number of ref_clk) in Legacy I2C Mode. As per specification, Min time value is 1300ns for Legacy FM Mode. As per specification, Min time value is 500ns for Legacy FM+ Mode. For 100MHz ref clock, total 130 clock periods are required. For FM Mode, the value of the register is 0x8C. For FM+ Mode, the value of this register is 0x3c. (access: R/W)
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_BIT                            0
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_WIDTH                          16
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_MASK                           0xffff
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_RESET                          0x8c
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TLOW_TIMER_REG_RESERVED_0_BIT                            16
        #define I3C_TLOW_TIMER_REG_RESERVED_0_WIDTH                          16
        #define I3C_TLOW_TIMER_REG_RESERVED_0_MASK                           0xffff0000
        #define I3C_TLOW_TIMER_REG_RESERVED_0_RESET                          0x0
        
        // High period of the SCL clock pin (Number of ref_clk) in Legacy I2C mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_BIT                          0
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_WIDTH                        16
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_MASK                         0xffff
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_RESET                        0x46
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THIGH_TIMER_REG_RESERVED_0_BIT                           16
        #define I3C_THIGH_TIMER_REG_RESERVED_0_WIDTH                         16
        #define I3C_THIGH_TIMER_REG_RESERVED_0_MASK                          0xffff0000
        #define I3C_THIGH_TIMER_REG_RESERVED_0_RESET                         0x0
        
        // Data Hold time (Number of ref_clk) in Legacy I2C mode. As per specification, Min Data setup time value is 100ns for Legacy FM Mode. So, hold time will be min 600 ns, so that the Legacy system works correctly. As per specification, Min Data setup time value is 50ns for Legacy FM+ Mode. So, hold time will be min 260 ns, so that the Legacy system works correctly. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_BIT                    0
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_WIDTH                  10
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_MASK                   0x3ff
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_RESET                  0x46
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_BIT                        10
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_WIDTH                      22
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_MASK                       0xfffffc00
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_RESET                      0x0
        
        // SDA Set up time (Number of ref_clk) for Stop condition during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_BIT                    0
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_WIDTH                  9
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_MASK                   0x1ff
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_RESET                  0x46
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_BIT                        9
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_WIDTH                      23
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_MASK                       0xfffffe00
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_RESET                      0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_RESET                 0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_BIT                  0
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_WIDTH                7
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_MASK                 0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_BIT                   24
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_MASK                  0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_RESET                 0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_BIT                  12
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_MASK                 0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_RESET                0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_BIT                  13
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_MASK                 0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_BIT                   14
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_MASK                  0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_RESET                 0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_BIT                    15
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_MASK                   0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_RESET                  0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_BIT                 16
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_WIDTH               8
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_MASK                0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_RESET               0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_BIT                  31
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_MASK                 0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_RESET                0x0
        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_BIT                  0
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_WIDTH                7
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_MASK                 0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_BIT                   24
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_MASK                  0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_RESET                 0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_BIT                  12
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_MASK                 0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_RESET                0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_BIT                  13
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_MASK                 0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_BIT                   14
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_MASK                  0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_RESET                 0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_BIT                    15
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_MASK                   0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_RESET                  0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_BIT                 16
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_WIDTH               8
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_MASK                0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_RESET               0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_BIT                  31
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_MASK                 0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_RESET                  0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_RESET                0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_RESET                  0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_RESET                0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_RESET                  0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_RESET                0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_RESET                  0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_RESET                0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_RESET                  0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_RESET                0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_RESET                  0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_RESET                0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_RESET                  0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_RESET                0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_RESET                  0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_RESET                0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_RESET                  0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_RESET                0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_RESET                0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_BIT                   0
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_WIDTH                 32
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_MASK                  0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_RESET                 0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_WIDTH                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_MASK                   0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_RESET                  0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_BIT                 16
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_WIDTH               16
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_MASK                0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_RESET               0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_BIT                        0
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_WIDTH                      8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_MASK                       0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_RESET                      0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_BIT                        8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_WIDTH                      8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_MASK                       0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_RESET                      0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_BIT               16
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_WIDTH             8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_MASK              0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_RESET             0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_BIT                 24
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_WIDTH               8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_MASK                0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_RESET               0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_BIT                 0
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_WIDTH               32
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_MASK                0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_RESET               0x0
        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_BIT                   0
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_WIDTH                 32
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_MASK                  0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_RESET                 0x0
        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_WIDTH                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_MASK                   0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_RESET                  0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_BIT                 16
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_WIDTH               16
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_MASK                0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_RESET               0x0
        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_BIT                        0
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_WIDTH                      8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_MASK                       0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_RESET                      0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_BIT                        8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_WIDTH                      8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_MASK                       0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_RESET                      0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_BIT               16
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_WIDTH             8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_MASK              0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_RESET             0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_BIT                 24
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_WIDTH               8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_MASK                0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_RESET               0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_BIT                 0
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_WIDTH               32
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_MASK                0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_RESET               0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_GET(value)   (GAP_BEXTRACTU((value),1,0))
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_GETS(value)  (GAP_BEXTRACT((value),1,0))
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_SET(value,field) (GAP_BINSERT((value),(field),1,0))
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN(val)         ((val) << 0)
        
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_GET(value)       (GAP_BEXTRACTU((value),1,1))
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_GETS(value)      (GAP_BEXTRACT((value),1,1))
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_SET(value,field) (GAP_BINSERT((value),(field),1,1))
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN(val)             ((val) << 1)
        
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_GET(value)          (GAP_BEXTRACTU((value),30,2))
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_GETS(value)         (GAP_BEXTRACT((value),30,2))
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_SET(value,field)    (GAP_BINSERT((value),(field),30,2))
        #define I3C_MST_CNTL_EN_REG_RESERVED_0(val)                ((val) << 2)
        
        #define I3C_CMD_TR_REQ_REG_1_DATA_GET(value)               (GAP_BEXTRACTU((value),32,0))
        #define I3C_CMD_TR_REQ_REG_1_DATA_GETS(value)              (GAP_BEXTRACT((value),32,0))
        #define I3C_CMD_TR_REQ_REG_1_DATA_SET(value,field)         (GAP_BINSERT((value),(field),32,0))
        #define I3C_CMD_TR_REQ_REG_1_DATA(val)                     ((val) << 0)
        
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_GET(value)            (GAP_BEXTRACTU((value),32,0))
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_GETS(value)           (GAP_BEXTRACT((value),32,0))
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_SET(value,field)      (GAP_BINSERT((value),(field),32,0))
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ(val)                  ((val) << 0)
        
        #define I3C_RESP_REG_RESP_REG_GET(value)                   (GAP_BEXTRACTU((value),32,0))
        #define I3C_RESP_REG_RESP_REG_GETS(value)                  (GAP_BEXTRACT((value),32,0))
        #define I3C_RESP_REG_RESP_REG_SET(value,field)             (GAP_BINSERT((value),(field),32,0))
        #define I3C_RESP_REG_RESP_REG(val)                         ((val) << 0)
        
        #define I3C_IBI_RESP_REG_DATA_LEN_GET(value)               (GAP_BEXTRACTU((value),8,0))
        #define I3C_IBI_RESP_REG_DATA_LEN_GETS(value)              (GAP_BEXTRACT((value),8,0))
        #define I3C_IBI_RESP_REG_DATA_LEN_SET(value,field)         (GAP_BINSERT((value),(field),8,0))
        #define I3C_IBI_RESP_REG_DATA_LEN(val)                     ((val) << 0)
        
        #define I3C_IBI_RESP_REG_IBI_ID_GET(value)                 (GAP_BEXTRACTU((value),8,8))
        #define I3C_IBI_RESP_REG_IBI_ID_GETS(value)                (GAP_BEXTRACT((value),8,8))
        #define I3C_IBI_RESP_REG_IBI_ID_SET(value,field)           (GAP_BINSERT((value),(field),8,8))
        #define I3C_IBI_RESP_REG_IBI_ID(val)                       ((val) << 8)
        
        #define I3C_IBI_RESP_REG_RESERVED_0_GET(value)             (GAP_BEXTRACTU((value),9,16))
        #define I3C_IBI_RESP_REG_RESERVED_0_GETS(value)            (GAP_BEXTRACT((value),9,16))
        #define I3C_IBI_RESP_REG_RESERVED_0_SET(value,field)       (GAP_BINSERT((value),(field),9,16))
        #define I3C_IBI_RESP_REG_RESERVED_0(val)                   ((val) << 16)
        
        #define I3C_IBI_RESP_REG_TS_PRESENT_GET(value)             (GAP_BEXTRACTU((value),1,25))
        #define I3C_IBI_RESP_REG_TS_PRESENT_GETS(value)            (GAP_BEXTRACT((value),1,25))
        #define I3C_IBI_RESP_REG_TS_PRESENT_SET(value,field)       (GAP_BINSERT((value),(field),1,25))
        #define I3C_IBI_RESP_REG_TS_PRESENT(val)                   ((val) << 25)
        
        #define I3C_IBI_RESP_REG_RESERVED_5_GET(value)             (GAP_BEXTRACTU((value),5,26))
        #define I3C_IBI_RESP_REG_RESERVED_5_GETS(value)            (GAP_BEXTRACT((value),5,26))
        #define I3C_IBI_RESP_REG_RESERVED_5_SET(value,field)       (GAP_BINSERT((value),(field),5,26))
        #define I3C_IBI_RESP_REG_RESERVED_5(val)                   ((val) << 26)
        
        #define I3C_IBI_RESP_REG_IBI_STS_GET(value)                (GAP_BEXTRACTU((value),1,31))
        #define I3C_IBI_RESP_REG_IBI_STS_GETS(value)               (GAP_BEXTRACT((value),1,31))
        #define I3C_IBI_RESP_REG_IBI_STS_SET(value,field)          (GAP_BINSERT((value),(field),1,31))
        #define I3C_IBI_RESP_REG_IBI_STS(val)                      ((val) << 31)
        
        #define I3C_IBI_DATA_REG_IBI_DATA_GET(value)               (GAP_BEXTRACTU((value),32,0))
        #define I3C_IBI_DATA_REG_IBI_DATA_GETS(value)              (GAP_BEXTRACT((value),32,0))
        #define I3C_IBI_DATA_REG_IBI_DATA_SET(value,field)         (GAP_BINSERT((value),(field),32,0))
        #define I3C_IBI_DATA_REG_IBI_DATA(val)                     ((val) << 0)
        
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_GET(value)            (GAP_BEXTRACTU((value),32,0))
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_GETS(value)           (GAP_BEXTRACT((value),32,0))
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_SET(value,field)      (GAP_BINSERT((value),(field),32,0))
        #define I3C_DATA_RX_FIFO_REG_DATA_RX(val)                  ((val) << 0)
        
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_GET(value)            (GAP_BEXTRACTU((value),32,0))
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_GETS(value)           (GAP_BEXTRACT((value),32,0))
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_SET(value,field)      (GAP_BINSERT((value),(field),32,0))
        #define I3C_DATA_TX_FIFO_REG_DATA_TX(val)                  ((val) << 0)
        
        #define I3C_IRQ_STATUS_REG_RESP_DONE_GET(value)            (GAP_BEXTRACTU((value),1,0))
        #define I3C_IRQ_STATUS_REG_RESP_DONE_GETS(value)           (GAP_BEXTRACT((value),1,0))
        #define I3C_IRQ_STATUS_REG_RESP_DONE_SET(value,field)      (GAP_BINSERT((value),(field),1,0))
        #define I3C_IRQ_STATUS_REG_RESP_DONE(val)                  ((val) << 0)
        
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_GET(value)    (GAP_BEXTRACTU((value),1,1))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_GETS(value)   (GAP_BEXTRACT((value),1,1))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_SET(value,field) (GAP_BINSERT((value),(field),1,1))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL(val)          ((val) << 1)
        
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_GET(value)   (GAP_BEXTRACTU((value),1,2))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_GETS(value)  (GAP_BEXTRACT((value),1,2))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_SET(value,field) (GAP_BINSERT((value),(field),1,2))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY(val)         ((val) << 2)
        
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_GET(value)    (GAP_BEXTRACTU((value),1,3))
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_GETS(value)   (GAP_BEXTRACT((value),1,3))
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_SET(value,field) (GAP_BINSERT((value),(field),1,3))
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL(val)          ((val) << 3)
        
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_GET(value)    (GAP_BEXTRACTU((value),1,4))
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_GETS(value)   (GAP_BEXTRACT((value),1,4))
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_SET(value,field) (GAP_BINSERT((value),(field),1,4))
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL(val)          ((val) << 4)
        
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_GET(value)           (GAP_BEXTRACTU((value),1,5))
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_GETS(value)          (GAP_BEXTRACT((value),1,5))
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_SET(value,field)     (GAP_BINSERT((value),(field),1,5))
        #define I3C_IRQ_STATUS_REG_RESP_COMPL(val)                 ((val) << 5)
        
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_GET(value)    (GAP_BEXTRACTU((value),1,6))
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_GETS(value)   (GAP_BEXTRACT((value),1,6))
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_SET(value,field) (GAP_BINSERT((value),(field),1,6))
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE(val)          ((val) << 6)
        
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_GET(value) (GAP_BEXTRACTU((value),1,7))
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_GETS(value) (GAP_BEXTRACT((value),1,7))
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_SET(value,field) (GAP_BINSERT((value),(field),1,7))
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL(val)      ((val) << 7)
        
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_GET(value)       (GAP_BEXTRACTU((value),1,8))
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_GETS(value)      (GAP_BEXTRACT((value),1,8))
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_SET(value,field) (GAP_BINSERT((value),(field),1,8))
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION(val)             ((val) << 8)
        
        #define I3C_IRQ_STATUS_REG_RESERVED_0_GET(value)           (GAP_BEXTRACTU((value),23,9))
        #define I3C_IRQ_STATUS_REG_RESERVED_0_GETS(value)          (GAP_BEXTRACT((value),23,9))
        #define I3C_IRQ_STATUS_REG_RESERVED_0_SET(value,field)     (GAP_BINSERT((value),(field),23,9))
        #define I3C_IRQ_STATUS_REG_RESERVED_0(val)                 ((val) << 9)
        
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_GET(value)           (GAP_BEXTRACTU((value),32,0))
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_GETS(value)          (GAP_BEXTRACT((value),32,0))
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_SET(value,field)     (GAP_BINSERT((value),(field),32,0))
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER(val)                 ((val) << 0)
        
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_GET(value)     (GAP_BEXTRACTU((value),5,0))
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_GETS(value)    (GAP_BEXTRACT((value),5,0))
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_SET(value,field) (GAP_BINSERT((value),(field),5,0))
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER(val)           ((val) << 0)
        
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_GET(value)        (GAP_BEXTRACTU((value),27,5))
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_GETS(value)       (GAP_BEXTRACT((value),27,5))
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_SET(value,field)  (GAP_BINSERT((value),(field),27,5))
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0(val)              ((val) << 5)
        
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_GET(value)   (GAP_BEXTRACTU((value),5,0))
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_GETS(value)  (GAP_BEXTRACT((value),5,0))
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_SET(value,field) (GAP_BINSERT((value),(field),5,0))
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER(val)         ((val) << 0)
        
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_GET(value)       (GAP_BEXTRACTU((value),27,5))
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_GETS(value)      (GAP_BEXTRACT((value),27,5))
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),27,5))
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0(val)             ((val) << 5)
        
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_GET(value)     (GAP_BEXTRACTU((value),5,0))
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_GETS(value)    (GAP_BEXTRACT((value),5,0))
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_SET(value,field) (GAP_BINSERT((value),(field),5,0))
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER(val)           ((val) << 0)
        
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_GET(value)        (GAP_BEXTRACTU((value),27,5))
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_GETS(value)       (GAP_BEXTRACT((value),27,5))
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_SET(value,field)  (GAP_BINSERT((value),(field),27,5))
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0(val)              ((val) << 5)
        
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_GET(value)   (GAP_BEXTRACTU((value),5,0))
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_GETS(value)  (GAP_BEXTRACT((value),5,0))
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_SET(value,field) (GAP_BINSERT((value),(field),5,0))
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER(val)         ((val) << 0)
        
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_GET(value)       (GAP_BEXTRACTU((value),27,5))
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_GETS(value)      (GAP_BEXTRACT((value),27,5))
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),27,5))
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0(val)             ((val) << 5)
        
        #define I3C_TDS_TIMER_REG_TDS_TIMER_GET(value)             (GAP_BEXTRACTU((value),3,0))
        #define I3C_TDS_TIMER_REG_TDS_TIMER_GETS(value)            (GAP_BEXTRACT((value),3,0))
        #define I3C_TDS_TIMER_REG_TDS_TIMER_SET(value,field)       (GAP_BINSERT((value),(field),3,0))
        #define I3C_TDS_TIMER_REG_TDS_TIMER(val)                   ((val) << 0)
        
        #define I3C_TDS_TIMER_REG_RESERVED_0_GET(value)            (GAP_BEXTRACTU((value),29,3))
        #define I3C_TDS_TIMER_REG_RESERVED_0_GETS(value)           (GAP_BEXTRACT((value),29,3))
        #define I3C_TDS_TIMER_REG_RESERVED_0_SET(value,field)      (GAP_BINSERT((value),(field),29,3))
        #define I3C_TDS_TIMER_REG_RESERVED_0(val)                  ((val) << 3)
        
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_GET(value)       (GAP_BEXTRACTU((value),3,0))
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_GETS(value)      (GAP_BEXTRACT((value),3,0))
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_SET(value,field) (GAP_BINSERT((value),(field),3,0))
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER(val)             ((val) << 0)
        
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_GET(value)         (GAP_BEXTRACTU((value),29,3))
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_GETS(value)        (GAP_BEXTRACT((value),29,3))
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_SET(value,field)   (GAP_BINSERT((value),(field),29,3))
        #define I3C_THD_PP_TIMER_REG_RESERVED_0(val)               ((val) << 3)
        
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_GET(value)           (GAP_BEXTRACTU((value),5,0))
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_GETS(value)          (GAP_BEXTRACT((value),5,0))
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_SET(value,field)     (GAP_BINSERT((value),(field),5,0))
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER(val)                 ((val) << 0)
        
        #define I3C_TCBP_TIMER_REG_RESERVED_0_GET(value)           (GAP_BEXTRACTU((value),27,5))
        #define I3C_TCBP_TIMER_REG_RESERVED_0_GETS(value)          (GAP_BEXTRACT((value),27,5))
        #define I3C_TCBP_TIMER_REG_RESERVED_0_SET(value,field)     (GAP_BINSERT((value),(field),27,5))
        #define I3C_TCBP_TIMER_REG_RESERVED_0(val)                 ((val) << 5)
        
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_GET(value)         (GAP_BEXTRACTU((value),3,0))
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_GETS(value)        (GAP_BEXTRACT((value),3,0))
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_SET(value,field)   (GAP_BINSERT((value),(field),3,0))
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER(val)               ((val) << 0)
        
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_GET(value)          (GAP_BEXTRACTU((value),29,3))
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_GETS(value)         (GAP_BEXTRACT((value),29,3))
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_SET(value,field)    (GAP_BINSERT((value),(field),29,3))
        #define I3C_TCBSR_TIMER_REG_RESERVED_0(val)                ((val) << 3)
        
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_GET(value)     (GAP_BEXTRACTU((value),3,0))
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_GETS(value)    (GAP_BEXTRACT((value),3,0))
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_SET(value,field) (GAP_BINSERT((value),(field),3,0))
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER(val)           ((val) << 0)
        
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_GET(value)        (GAP_BEXTRACTU((value),29,3))
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_GETS(value)       (GAP_BEXTRACT((value),29,3))
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_SET(value,field)  (GAP_BINSERT((value),(field),29,3))
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0(val)              ((val) << 3)
        
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER(val)         ((val) << 0)
        
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER(val)       ((val) << 0)
        
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_GET(value)         (GAP_BEXTRACTU((value),32,0))
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_GETS(value)        (GAP_BEXTRACT((value),32,0))
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_SET(value,field)   (GAP_BINSERT((value),(field),32,0))
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER(val)               ((val) << 0)
        
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_GET(value)           (GAP_BEXTRACTU((value),3,0))
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_GETS(value)          (GAP_BEXTRACT((value),3,0))
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_SET(value,field)     (GAP_BINSERT((value),(field),3,0))
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER(val)                 ((val) << 0)
        
        #define I3C_TSCO_TIMER_REG_RESERVED_0_GET(value)           (GAP_BEXTRACTU((value),29,3))
        #define I3C_TSCO_TIMER_REG_RESERVED_0_GETS(value)          (GAP_BEXTRACT((value),29,3))
        #define I3C_TSCO_TIMER_REG_RESERVED_0_SET(value,field)     (GAP_BINSERT((value),(field),29,3))
        #define I3C_TSCO_TIMER_REG_RESERVED_0(val)                 ((val) << 3)
        
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_GET(value)     (GAP_BEXTRACTU((value),9,0))
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_GETS(value)    (GAP_BEXTRACT((value),9,0))
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_SET(value,field) (GAP_BINSERT((value),(field),9,0))
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER(val)           ((val) << 0)
        
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_GET(value)        (GAP_BEXTRACTU((value),23,9))
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_GETS(value)       (GAP_BEXTRACT((value),23,9))
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_SET(value,field)  (GAP_BINSERT((value),(field),23,9))
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0(val)              ((val) << 9)
        
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_GET(value)     (GAP_BEXTRACTU((value),9,0))
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_GETS(value)    (GAP_BEXTRACT((value),9,0))
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_SET(value,field) (GAP_BINSERT((value),(field),9,0))
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER(val)           ((val) << 0)
        
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_GET(value)           (GAP_BEXTRACTU((value),16,0))
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_GETS(value)          (GAP_BEXTRACT((value),16,0))
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_SET(value,field)     (GAP_BINSERT((value),(field),16,0))
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER(val)                 ((val) << 0)
        
        #define I3C_TLOW_TIMER_REG_RESERVED_0_GET(value)           (GAP_BEXTRACTU((value),16,16))
        #define I3C_TLOW_TIMER_REG_RESERVED_0_GETS(value)          (GAP_BEXTRACT((value),16,16))
        #define I3C_TLOW_TIMER_REG_RESERVED_0_SET(value,field)     (GAP_BINSERT((value),(field),16,16))
        #define I3C_TLOW_TIMER_REG_RESERVED_0(val)                 ((val) << 16)
        
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_GET(value)         (GAP_BEXTRACTU((value),16,0))
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_GETS(value)        (GAP_BEXTRACT((value),16,0))
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_SET(value,field)   (GAP_BINSERT((value),(field),16,0))
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER(val)               ((val) << 0)
        
        #define I3C_THIGH_TIMER_REG_RESERVED_0_GET(value)          (GAP_BEXTRACTU((value),16,16))
        #define I3C_THIGH_TIMER_REG_RESERVED_0_GETS(value)         (GAP_BEXTRACT((value),16,16))
        #define I3C_THIGH_TIMER_REG_RESERVED_0_SET(value,field)    (GAP_BINSERT((value),(field),16,16))
        #define I3C_THIGH_TIMER_REG_RESERVED_0(val)                ((val) << 16)
        
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_GET(value)   (GAP_BEXTRACTU((value),10,0))
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_GETS(value)  (GAP_BEXTRACT((value),10,0))
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_SET(value,field) (GAP_BINSERT((value),(field),10,0))
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER(val)         ((val) << 0)
        
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_GET(value)       (GAP_BEXTRACTU((value),22,10))
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_GETS(value)      (GAP_BEXTRACT((value),22,10))
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),22,10))
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0(val)             ((val) << 10)
        
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_GET(value)   (GAP_BEXTRACTU((value),9,0))
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_GETS(value)  (GAP_BEXTRACT((value),9,0))
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_SET(value,field) (GAP_BINSERT((value),(field),9,0))
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER(val)         ((val) << 0)
        
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_GET(value)       (GAP_BEXTRACTU((value),23,9))
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_GETS(value)      (GAP_BEXTRACT((value),23,9))
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),23,9))
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0(val)             ((val) << 9)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE(val)        ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_GET(value) (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR(val)       ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_GET(value)  (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0(val)        ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_GET(value) (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD(val)       ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_GET(value) (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ(val)       ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_GET(value)  (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_GETS(value) (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5(val)        ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_GET(value)   (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_GETS(value)  (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP(val)         ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR(val)      ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_GET(value) (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE(val)       ((val) << 31)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_GET(value) (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR(val)       ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_GET(value)  (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0(val)        ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_GET(value) (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD(val)       ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_GET(value) (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ(val)       ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_GET(value)  (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_GETS(value) (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5(val)        ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_GET(value)   (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_GETS(value)  (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP(val)         ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR(val)      ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_GET(value) (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE(val)       ((val) << 31)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0(val)       ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0(val)       ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0(val)       ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0(val)       ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0(val)       ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0(val)       ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0(val)       ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0(val)       ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0(val)       ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0(val)       ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0(val)       ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0(val)       ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0(val)       ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0(val)       ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0(val)       ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0(val)       ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0(val)       ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0(val)       ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0(val)       ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0(val)       ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0(val)       ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0(val)       ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0(val)       ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0(val)       ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0(val)       ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0(val)       ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0(val)       ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_GET(value)  (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH(val)        ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_GET(value)   (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_GETS(value)  (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0(val)      ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_GET(value)       (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_GETS(value)      (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_SET(value,field) (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR(val)             ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_GET(value)       (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_GETS(value)      (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_SET(value,field) (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR(val)             ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR(val)    ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0(val)      ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0(val)      ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_GET(value)  (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH(val)        ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_GET(value)   (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_GETS(value)  (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0(val)      ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_GET(value)       (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_GETS(value)      (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_SET(value,field) (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR(val)             ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_GET(value)       (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_GETS(value)      (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_SET(value,field) (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR(val)             ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR(val)    ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0(val)      ((val) << 24)
        
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0(val)      ((val) << 0)

.. toggle-header::
    :header: *Register map structure*

    .. code-block:: c

        /** I3C_Type Register Layout Typedef */
        typedef struct {
            volatile uint32_t mst_cntl_en_reg;  // I3C Master control.
            volatile uint32_t cmd_tr_req_reg_1;  // Data length or Data byte value to be sent along with the CCC or HDR command.
            volatile uint32_t cmd_tr_req_reg_2;  // Command type, Transaction ID, CCC code and slave address. Writing to this register is considered as Doorbell for the master to initiate the transfer.
            volatile uint32_t reserved_0[1];  // Reserved/Not used.
            volatile uint32_t resp_reg;  // Success or failure of the command, Transaction ID and the remaining data.
            volatile uint32_t ibi_resp_reg;  // In-Band interrupt status, timestamping information present, dynamic address of the slave or Hot Join request.
            volatile uint32_t ibi_data_reg;  // Data received from the slave during the IBI process.
            volatile uint32_t data_rx_fifo_reg;  // Received data FIFO (Data_RX_FIFO).
            volatile uint32_t data_tx_fifo_reg;  // Sending data FIFO (Data_TX_FIFO).
            volatile uint32_t reserved_1[3];  // Reserved/Not used.
            volatile uint32_t irq_status_reg;  // Status of the event happened during the transfer.
            volatile uint32_t reserved_2[3];  // Reserved/Not used.
            volatile uint32_t tcas_timer_reg;  // Timing for Clock after Start condition (TCAS) is the time (in Number of Reference clocks) after the start condition after which the SCL pin can go low.
            volatile uint32_t tlow_od_timer_reg;  // Low period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go high.
            volatile uint32_t thigh_od_timer_reg;  // High period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go low.
            volatile uint32_t tlow_pp_timer_reg;  // Low period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go high.
            volatile uint32_t thigh_pp_timer_reg;  // High period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go low.
            volatile uint32_t tds_timer_reg;  // SDA data setup time during both Open-Drain/Push-Pull mode (in Number of Reference clock).
            volatile uint32_t thd_pp_timer_reg;  // SDA data hold time during the Push-Pull mode (in Number of Reference clock).
            volatile uint32_t tcbp_timer_reg;  // Clock time before Stop condition.
            volatile uint32_t tcbsr_timer_reg;  // Clock time before Repeated start condition.
            volatile uint32_t thd_ddr_timer_reg;  // SDA data hold time during the Push-Pull mode (in Number of Reference clock) in DDR Data rate.
            volatile uint32_t bus_free_timer_reg;  // Bus free time between the Stop condition and the next start condition (in Number of Reference clock).
            volatile uint32_t bus_avail_timer_reg;  // Time to keep the SDA and SCL pin to High (in Number of Reference clock).
            volatile uint32_t tidle_timer_reg;  // Extended duration of the bus free condition after the Stop condition (in Number of Reference clock) to enable the device to drive the Hot Join request.
            volatile uint32_t tsco_timer_reg;  // Maximum time the slave needs to drive the bus during the ACK/read data after the clock change.
            volatile uint32_t reserved_3[6];  // Reserved/Not used.
            volatile uint32_t tsu_sta_timer_reg;  // SDA data setup time during both Open-Drain (in Number of Reference clock) for a Repeated Start.
            volatile uint32_t thd_sta_timer_reg;  // SDA data hold time during the Open Drain mode (in Number of Reference clock).
            volatile uint32_t tlow_timer_reg;  // Low period of SCL pin in Open Drain mode during Legacy I2c Mode (in Number of Reference clock) after the timer reached the SCL pin can go high.
            volatile uint32_t thigh_timer_reg;  // High period of SCL pin in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SCL pin can go low.
            volatile uint32_t tvd_data_timer_reg;  // Data hold time in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SDA pin can change its value.
            volatile uint32_t reserved_4[1];  // Reserved/Not used.
            volatile uint32_t tsu_stop_timer_reg;  // SDA data setup time during Open-Drain (in Number of Reference clock) for Stop condition.
            volatile uint32_t reserved_5[21];  // Reserved/Not used.
            volatile uint32_t device_addr_table_reg0;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave0.
            volatile uint32_t device_addr_table_reg1;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave1.
            volatile uint32_t device_addr_table_reg2;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave2.
            volatile uint32_t device_addr_table_reg3;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave3.
            volatile uint32_t device_addr_table_reg4;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave4.
            volatile uint32_t device_addr_table_reg5;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave5.
            volatile uint32_t device_addr_table_reg6;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave6.
            volatile uint32_t device_addr_table_reg7;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave7.
            volatile uint32_t device_addr_table_reg8;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave8.
            volatile uint32_t device_addr_table_reg9;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave9.
            volatile uint32_t device_addr_table_reg10;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave10.
            volatile uint32_t device_addr_table_reg11;  // Device type, IBI handling and Dynamic address to be set and Static address of the slave11.
            volatile uint32_t reserved_6[52];  // Reserved/Not used.
            volatile uint32_t device_char_table_reg0_0;  // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_0;  // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_0;  // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_0;  // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_1;  // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_1;  // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_1;  // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_1;  // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_2;  // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_2;  // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_2;  // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_2;  // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_3;  // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_3;  // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_3;  // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_3;  // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_4;  // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_4;  // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_4;  // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_4;  // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_5;  // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_5;  // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_5;  // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_5;  // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_6;  // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_6;  // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_6;  // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_6;  // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_7;  // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_7;  // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_7;  // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_7;  // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_8;  // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_8;  // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_8;  // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_8;  // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_9;  // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_9;  // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_9;  // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_9;  // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_10;  // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_10;  // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_10;  // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_10;  // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg0_11;  // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg1_11;  // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg2_11;  // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
            volatile uint32_t device_char_table_reg3_11;  // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
        } __attribute__((packed)) i3c_t;

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int master_control_en:1 ; // Master control enable : To enable the I3C Master controller for any transfers. -1b0 : I3C Master is disabled -1b1 : I3C master is enabled
            unsigned int master_rst_en   :1 ; // Master Reset enable (Soft reset) : To enable the I3C Master controller to issue Soft reset during any transfers. Soft reset will be applied after the completion of ACK/NACK state. -1b0 : I3C Master reset is disabled -1b1 : I3C master reset is enabled
            unsigned int reserved_0      :30; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_mst_cntl_en_reg_t;
        
        typedef union {
          struct {
            unsigned int data            :32; // Data length or Data byte value. This register contains Data length or Data byte value depending on the type of command being initiated.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_cmd_tr_req_reg_1_t;
        
        typedef union {
          struct {
            unsigned int cmd_req         :32; // Command request. This register contains information about the command type, Transaction ID, slave address and the type of CCC or HDR to be initiated.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_cmd_tr_req_reg_2_t;
        
        typedef union {
          struct {
            unsigned int resp_reg        :32; // Response register. Contains values of the success/failure of the command, transaction ID of the completed command & remaining data (for write transfer) or received data length (for read transfer) or number of remaining slaves (for dynamic address command).
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_resp_reg_t;
        
        typedef union {
          struct {
            unsigned int data_len        :8 ; // IBI Data length. Number of bytes in the IBI requests received.
            unsigned int ibi_id          :8 ; // IBI received ID. Contains slave address for IBI. Contains Hot Join ID for the Hot-Join IBI
            unsigned int reserved_0      :9 ; // Reserved/Not used.
            unsigned int ts_present      :1 ; // IBI timestamp present for IBI : -1b1 : IBI is timestamped -1b0 : IBI is not timestamped
            unsigned int reserved_5      :5 ; // Reserved/Not used.
            unsigned int ibi_sts         :1 ; // IBI status. Indicates how the IBI is handled : -1b0 : Indicates IBI is handled with ACK -1b1 : Indicates IBI is handled with NACK
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_ibi_resp_reg_t;
        
        typedef union {
          struct {
            unsigned int ibi_data        :32; // IBI Data. Data received during the IBI process is stored in FIFO and is sent out to the Software using this register.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_ibi_data_reg_t;
        
        typedef union {
          struct {
            unsigned int data_rx         :32; // All the Data received from the slave is stored in FIFO. On request by the software, the FIFO read and the values are provided.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_data_rx_fifo_reg_t;
        
        typedef union {
          struct {
            unsigned int data_tx         :32; // Write data to be sent from the Master to the slave. Software writes this register for sending the write data to the slave.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_data_tx_fifo_reg_t;
        
        typedef union {
          struct {
            unsigned int resp_done       :1 ; // Indicates the response completion is done.
            unsigned int data_tx_fifo_full:1 ; // Indicates the Data Tx FIFO is full.
            unsigned int data_tx_fifo_empty:1 ; // Indicates the Data Tx FIFO is empty.
            unsigned int cmd_req_fifo_full:1 ; // Indicates the command transfer request FIFO Full.
            unsigned int data_rx_fifo_full:1 ; // Indicates the Data Rx FIFO Full.
            unsigned int resp_compl      :1 ; // Indicates the response completion FIFO is full.
            unsigned int ibi_transfer_done:1 ; // Indicates the IBI request is received from slave.
            unsigned int ibi_data_rx_fifo_full:1 ; // Indicates the IBI payload is full.
            unsigned int rst_completion  :1 ; // Indicates the Master controller issued soft reset.
            unsigned int reserved_0      :23; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_irq_status_reg_t;
        
        typedef union {
          struct {
            unsigned int tcas_timer      :32; // Timing of the SCL pin to go low after the start condition (Number of ref_clk). As per specification, Min time value is 38.4ns. For 100MHz ref clock, total 4 clock periods are required. So, the value of the register is 0x3.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tcas_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tlow_od_timer   :5 ; // Low period of the SCL clock pin (Number of ref_clk). As per specification, Min time value is 200ns + fall time of SDA signal. For 100MHz ref clock, total 24 clock periods are required. So, the value of the register is 0x23.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tlow_od_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int thigh_od_timer  :5 ; // High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods is allowed. So, the value of the register is 0x2.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thigh_od_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tlow_pp_timer   :5 ; // Low period of the SCL clock pin (Number of ref_clk) in Push pull mode. As per specification, Min time value is 24ns. For 100MHz ref clock, total 3 clock periods are required. So, the value of the register is 0x3.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tlow_pp_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int thigh_pp_timer  :5 ; // High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods are required. So, the value of the register is 0x2.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thigh_pp_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tds_timer       :3 ; // SDA Set up time (Number of ref_clk). As per specification, Min time value is 3ns. For 100MHz ref clock, Max. of total 1 clock period is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tds_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int thd_pp_timer    :3 ; // SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thd_pp_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tcbp_timer      :5 ; // To signal STOP condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tcbp_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tcbsr_timer     :3 ; // To signal Repeated start condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tcbsr_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int thd_ddr_timer   :3 ; // SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thd_ddr_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int bus_free_timer  :32; // Bus free time after the STOP condition and the Start condition. As per specification, Min. value of this period is 1us.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_bus_free_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int bus_avail_timer :32; // Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1us.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_bus_avail_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tidle_timer     :32; // Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1ms.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tidle_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tsco_timer      :3 ; // Maximum time for the slave to release bus after the clock change. As per specification, Max. value is 12ns.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tsco_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tsu_sta_timer   :9 ; // SDA Set up time (Number of ref_clk) for a Repeated Start during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
            unsigned int reserved_0      :23; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tsu_sta_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int thd_sta_timer   :9 ; // SDA Hold time (Number of ref_clk) after Start/Repeated Start. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thd_sta_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tlow_timer      :16; // Low period of the SCL clock pin (Number of ref_clk) in Legacy I2C Mode. As per specification, Min time value is 1300ns for Legacy FM Mode. As per specification, Min time value is 500ns for Legacy FM+ Mode. For 100MHz ref clock, total 130 clock periods are required. For FM Mode, the value of the register is 0x8C. For FM+ Mode, the value of this register is 0x3c.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tlow_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int thigh_timer     :16; // High period of the SCL clock pin (Number of ref_clk) in Legacy I2C mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thigh_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tvd_data_timer  :10; // Data Hold time (Number of ref_clk) in Legacy I2C mode. As per specification, Min Data setup time value is 100ns for Legacy FM Mode. So, hold time will be min 600 ns, so that the Legacy system works correctly. As per specification, Min Data setup time value is 50ns for Legacy FM+ Mode. So, hold time will be min 260 ns, so that the Legacy system works correctly. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
            unsigned int reserved_0      :22; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tvd_data_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int tsu_stop_timer  :9 ; // SDA Set up time (Number of ref_clk) for Stop condition during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
            unsigned int reserved_0      :23; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tsu_stop_timer_reg_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg0_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg1_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg2_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg3_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg4_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg5_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg6_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg7_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg8_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg9_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg10_t;
        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg11_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_0_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_0_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_0_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_0_t;
        
        typedef union {
          struct {
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_1_t;
        
        typedef union {
          struct {
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_1_t;
        
        typedef union {
          struct {
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_1_t;
        
        typedef union {
          struct {
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_1_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_2_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_2_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_2_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_2_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_3_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_3_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_3_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_3_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_4_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_4_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_4_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_4_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_5_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_5_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_5_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_5_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_6_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_6_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_6_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_6_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_7_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_7_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_7_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_7_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_8_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_8_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_8_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_8_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_9_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_9_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_9_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_9_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_10_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_10_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_10_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_10_t;
        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_11_t;
        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_11_t;
        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_11_t;
        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_11_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_regmap_i3c : public vp::regmap
        {
        public:
            vp_i3c_mst_cntl_en_reg mst_cntl_en_reg;
            vp_i3c_cmd_tr_req_reg_1 cmd_tr_req_reg_1;
            vp_i3c_cmd_tr_req_reg_2 cmd_tr_req_reg_2;
            vp_i3c_resp_reg resp_reg;
            vp_i3c_ibi_resp_reg ibi_resp_reg;
            vp_i3c_ibi_data_reg ibi_data_reg;
            vp_i3c_data_rx_fifo_reg data_rx_fifo_reg;
            vp_i3c_data_tx_fifo_reg data_tx_fifo_reg;
            vp_i3c_irq_status_reg irq_status_reg;
            vp_i3c_tcas_timer_reg tcas_timer_reg;
            vp_i3c_tlow_od_timer_reg tlow_od_timer_reg;
            vp_i3c_thigh_od_timer_reg thigh_od_timer_reg;
            vp_i3c_tlow_pp_timer_reg tlow_pp_timer_reg;
            vp_i3c_thigh_pp_timer_reg thigh_pp_timer_reg;
            vp_i3c_tds_timer_reg tds_timer_reg;
            vp_i3c_thd_pp_timer_reg thd_pp_timer_reg;
            vp_i3c_tcbp_timer_reg tcbp_timer_reg;
            vp_i3c_tcbsr_timer_reg tcbsr_timer_reg;
            vp_i3c_thd_ddr_timer_reg thd_ddr_timer_reg;
            vp_i3c_bus_free_timer_reg bus_free_timer_reg;
            vp_i3c_bus_avail_timer_reg bus_avail_timer_reg;
            vp_i3c_tidle_timer_reg tidle_timer_reg;
            vp_i3c_tsco_timer_reg tsco_timer_reg;
            vp_i3c_tsu_sta_timer_reg tsu_sta_timer_reg;
            vp_i3c_thd_sta_timer_reg thd_sta_timer_reg;
            vp_i3c_tlow_timer_reg tlow_timer_reg;
            vp_i3c_thigh_timer_reg thigh_timer_reg;
            vp_i3c_tvd_data_timer_reg tvd_data_timer_reg;
            vp_i3c_tsu_stop_timer_reg tsu_stop_timer_reg;
            vp_i3c_device_addr_table_reg0 device_addr_table_reg0;
            vp_i3c_device_addr_table_reg1 device_addr_table_reg1;
            vp_i3c_device_addr_table_reg2 device_addr_table_reg2;
            vp_i3c_device_addr_table_reg3 device_addr_table_reg3;
            vp_i3c_device_addr_table_reg4 device_addr_table_reg4;
            vp_i3c_device_addr_table_reg5 device_addr_table_reg5;
            vp_i3c_device_addr_table_reg6 device_addr_table_reg6;
            vp_i3c_device_addr_table_reg7 device_addr_table_reg7;
            vp_i3c_device_addr_table_reg8 device_addr_table_reg8;
            vp_i3c_device_addr_table_reg9 device_addr_table_reg9;
            vp_i3c_device_addr_table_reg10 device_addr_table_reg10;
            vp_i3c_device_addr_table_reg11 device_addr_table_reg11;
            vp_i3c_device_char_table_reg0_0 device_char_table_reg0_0;
            vp_i3c_device_char_table_reg1_0 device_char_table_reg1_0;
            vp_i3c_device_char_table_reg2_0 device_char_table_reg2_0;
            vp_i3c_device_char_table_reg3_0 device_char_table_reg3_0;
            vp_i3c_device_char_table_reg0_1 device_char_table_reg0_1;
            vp_i3c_device_char_table_reg1_1 device_char_table_reg1_1;
            vp_i3c_device_char_table_reg2_1 device_char_table_reg2_1;
            vp_i3c_device_char_table_reg3_1 device_char_table_reg3_1;
            vp_i3c_device_char_table_reg0_2 device_char_table_reg0_2;
            vp_i3c_device_char_table_reg1_2 device_char_table_reg1_2;
            vp_i3c_device_char_table_reg2_2 device_char_table_reg2_2;
            vp_i3c_device_char_table_reg3_2 device_char_table_reg3_2;
            vp_i3c_device_char_table_reg0_3 device_char_table_reg0_3;
            vp_i3c_device_char_table_reg1_3 device_char_table_reg1_3;
            vp_i3c_device_char_table_reg2_3 device_char_table_reg2_3;
            vp_i3c_device_char_table_reg3_3 device_char_table_reg3_3;
            vp_i3c_device_char_table_reg0_4 device_char_table_reg0_4;
            vp_i3c_device_char_table_reg1_4 device_char_table_reg1_4;
            vp_i3c_device_char_table_reg2_4 device_char_table_reg2_4;
            vp_i3c_device_char_table_reg3_4 device_char_table_reg3_4;
            vp_i3c_device_char_table_reg0_5 device_char_table_reg0_5;
            vp_i3c_device_char_table_reg1_5 device_char_table_reg1_5;
            vp_i3c_device_char_table_reg2_5 device_char_table_reg2_5;
            vp_i3c_device_char_table_reg3_5 device_char_table_reg3_5;
            vp_i3c_device_char_table_reg0_6 device_char_table_reg0_6;
            vp_i3c_device_char_table_reg1_6 device_char_table_reg1_6;
            vp_i3c_device_char_table_reg2_6 device_char_table_reg2_6;
            vp_i3c_device_char_table_reg3_6 device_char_table_reg3_6;
            vp_i3c_device_char_table_reg0_7 device_char_table_reg0_7;
            vp_i3c_device_char_table_reg1_7 device_char_table_reg1_7;
            vp_i3c_device_char_table_reg2_7 device_char_table_reg2_7;
            vp_i3c_device_char_table_reg3_7 device_char_table_reg3_7;
            vp_i3c_device_char_table_reg0_8 device_char_table_reg0_8;
            vp_i3c_device_char_table_reg1_8 device_char_table_reg1_8;
            vp_i3c_device_char_table_reg2_8 device_char_table_reg2_8;
            vp_i3c_device_char_table_reg3_8 device_char_table_reg3_8;
            vp_i3c_device_char_table_reg0_9 device_char_table_reg0_9;
            vp_i3c_device_char_table_reg1_9 device_char_table_reg1_9;
            vp_i3c_device_char_table_reg2_9 device_char_table_reg2_9;
            vp_i3c_device_char_table_reg3_9 device_char_table_reg3_9;
            vp_i3c_device_char_table_reg0_10 device_char_table_reg0_10;
            vp_i3c_device_char_table_reg1_10 device_char_table_reg1_10;
            vp_i3c_device_char_table_reg2_10 device_char_table_reg2_10;
            vp_i3c_device_char_table_reg3_10 device_char_table_reg3_10;
            vp_i3c_device_char_table_reg0_11 device_char_table_reg0_11;
            vp_i3c_device_char_table_reg1_11 device_char_table_reg1_11;
            vp_i3c_device_char_table_reg2_11 device_char_table_reg2_11;
            vp_i3c_device_char_table_reg3_11 device_char_table_reg3_11;
        };

|

.. _i3c_Mst_Cntl_En_Reg:

Mst_Cntl_En_Reg
"""""""""""""""

I3C Master control.

.. table:: 

    +-----+---+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|      Name       |                                                                                                                        Description                                                                                                                         |
    +=====+===+=================+============================================================================================================================================================================================================================================================+
    |    0|R/W|MASTER_CONTROL_EN|Master control enable : To enable the I3C Master controller for any transfers. -1’b0 : I3C Master is disabled -1’b1 : I3C master is enabled                                                                                                                 |
    +-----+---+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |    1|R/W|MASTER_RST_EN    |Master Reset enable (Soft reset) : To enable the I3C Master controller to issue Soft reset during any transfers. Soft reset will be applied after the completion of ACK/NACK state. -1’b0 : I3C Master reset is disabled -1’b1 : I3C master reset is enabled|
    +-----+---+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:2 |R/W|RESERVED_0       |Reserved/Not used.                                                                                                                                                                                                                                          |
    +-----+---+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // I3C Master control.
                #define I3C_MST_CNTL_EN_REG_OFFSET               0x0

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_mst_cntl_en_reg_get(uint32_t base);
        static inline void i3c_mst_cntl_en_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Master control enable : To enable the I3C Master controller for any transfers. -1b0 : I3C Master is disabled -1b1 : I3C master is enabled (access: R/W)
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_BIT                    0
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_WIDTH                  1
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_MASK                   0x1
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_RESET                  0x0
        
        // Master Reset enable (Soft reset) : To enable the I3C Master controller to issue Soft reset during any transfers. Soft reset will be applied after the completion of ACK/NACK state. -1b0 : I3C Master reset is disabled -1b1 : I3C master reset is enabled (access: R/W)
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_BIT                        1
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_WIDTH                      1
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_MASK                       0x2
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_RESET                      0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_BIT                           2
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_WIDTH                         30
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_MASK                          0xfffffffc
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_RESET                         0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_GET(value)   (GAP_BEXTRACTU((value),1,0))
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_GETS(value)  (GAP_BEXTRACT((value),1,0))
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN_SET(value,field) (GAP_BINSERT((value),(field),1,0))
        #define I3C_MST_CNTL_EN_REG_MASTER_CONTROL_EN(val)         ((val) << 0)
        
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_GET(value)       (GAP_BEXTRACTU((value),1,1))
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_GETS(value)      (GAP_BEXTRACT((value),1,1))
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN_SET(value,field) (GAP_BINSERT((value),(field),1,1))
        #define I3C_MST_CNTL_EN_REG_MASTER_RST_EN(val)             ((val) << 1)
        
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_GET(value)          (GAP_BEXTRACTU((value),30,2))
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_GETS(value)         (GAP_BEXTRACT((value),30,2))
        #define I3C_MST_CNTL_EN_REG_RESERVED_0_SET(value,field)    (GAP_BINSERT((value),(field),30,2))
        #define I3C_MST_CNTL_EN_REG_RESERVED_0(val)                ((val) << 2)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int master_control_en:1 ; // Master control enable : To enable the I3C Master controller for any transfers. -1b0 : I3C Master is disabled -1b1 : I3C master is enabled
            unsigned int master_rst_en   :1 ; // Master Reset enable (Soft reset) : To enable the I3C Master controller to issue Soft reset during any transfers. Soft reset will be applied after the completion of ACK/NACK state. -1b0 : I3C Master reset is disabled -1b1 : I3C master reset is enabled
            unsigned int reserved_0      :30; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_mst_cntl_en_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_mst_cntl_en_reg : public vp::reg_32
        {
        public:
            inline void master_control_en_set(uint32_t value);
            inline uint32_t master_control_en_get();
            inline void master_rst_en_set(uint32_t value);
            inline uint32_t master_rst_en_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_CMD_Tr_Req_Reg_1:

CMD_Tr_Req_Reg_1
""""""""""""""""

Data length or Data byte value to be sent along with the CCC or HDR command.

.. table:: 

    +-----+---+----+---------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|Name|                                                              Description                                                              |
    +=====+===+====+=======================================================================================================================================+
    |31:0 |W  |DATA|Data length or Data byte value. This register contains Data length or Data byte value depending on the type of command being initiated.|
    +-----+---+----+---------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Data length or Data byte value to be sent along with the CCC or HDR command.
                #define I3C_CMD_TR_REQ_REG_1_OFFSET              0x4

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_cmd_tr_req_reg_1_get(uint32_t base);
        static inline void i3c_cmd_tr_req_reg_1_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Data length or Data byte value. This register contains Data length or Data byte value depending on the type of command being initiated. (access: W)
        #define I3C_CMD_TR_REQ_REG_1_DATA_BIT                                0
        #define I3C_CMD_TR_REQ_REG_1_DATA_WIDTH                              32
        #define I3C_CMD_TR_REQ_REG_1_DATA_MASK                               0xffffffff
        #define I3C_CMD_TR_REQ_REG_1_DATA_RESET                              0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_CMD_TR_REQ_REG_1_DATA_GET(value)               (GAP_BEXTRACTU((value),32,0))
        #define I3C_CMD_TR_REQ_REG_1_DATA_GETS(value)              (GAP_BEXTRACT((value),32,0))
        #define I3C_CMD_TR_REQ_REG_1_DATA_SET(value,field)         (GAP_BINSERT((value),(field),32,0))
        #define I3C_CMD_TR_REQ_REG_1_DATA(val)                     ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int data            :32; // Data length or Data byte value. This register contains Data length or Data byte value depending on the type of command being initiated.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_cmd_tr_req_reg_1_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_cmd_tr_req_reg_1 : public vp::reg_32
        {
        public:
            inline void data_set(uint32_t value);
            inline uint32_t data_get();
        };

|

.. _i3c_CMD_Tr_Req_Reg_2:

CMD_Tr_Req_Reg_2
""""""""""""""""

Command type, Transaction ID, CCC code and slave address. Writing to this register is considered as Doorbell for the master to initiate the transfer.

.. table:: 

    +-----+---+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W| Name  |                                                                     Description                                                                     |
    +=====+===+=======+=====================================================================================================================================================+
    |31:0 |W  |CMD_REQ|Command request. This register contains information about the command type, Transaction ID, slave address and the type of CCC or HDR to be initiated.|
    +-----+---+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Command type, Transaction ID, CCC code and slave address. Writing to this register is considered as Doorbell for the master to initiate the transfer.
                #define I3C_CMD_TR_REQ_REG_2_OFFSET              0x8

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_cmd_tr_req_reg_2_get(uint32_t base);
        static inline void i3c_cmd_tr_req_reg_2_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Command request. This register contains information about the command type, Transaction ID, slave address and the type of CCC or HDR to be initiated. (access: W)
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_BIT                             0
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_WIDTH                           32
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_MASK                            0xffffffff
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_RESET                           0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_GET(value)            (GAP_BEXTRACTU((value),32,0))
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_GETS(value)           (GAP_BEXTRACT((value),32,0))
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ_SET(value,field)      (GAP_BINSERT((value),(field),32,0))
        #define I3C_CMD_TR_REQ_REG_2_CMD_REQ(val)                  ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int cmd_req         :32; // Command request. This register contains information about the command type, Transaction ID, slave address and the type of CCC or HDR to be initiated.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_cmd_tr_req_reg_2_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_cmd_tr_req_reg_2 : public vp::reg_32
        {
        public:
            inline void cmd_req_set(uint32_t value);
            inline uint32_t cmd_req_get();
        };

|

.. _i3c_Resp_Reg:

Resp_Reg
""""""""

Success or failure of the command, Transaction ID and the remaining data.

.. table:: 

    +-----+---+--------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|  Name  |                                                                                                                          Description                                                                                                                           |
    +=====+===+========+================================================================================================================================================================================================================================================================+
    |31:0 |R  |RESP_REG|Response register. Contains values of the success/failure of the command, transaction ID of the completed command & remaining data (for write transfer) or received data length (for read transfer) or number of remaining slaves (for dynamic address command).|
    +-----+---+--------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Success or failure of the command, Transaction ID and the remaining data.
                #define I3C_RESP_REG_OFFSET                      0x10

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_resp_reg_get(uint32_t base);
        static inline void i3c_resp_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Response register. Contains values of the success/failure of the command, transaction ID of the completed command & remaining data (for write transfer) or received data length (for read transfer) or number of remaining slaves (for dynamic address command). (access: R)
        #define I3C_RESP_REG_RESP_REG_BIT                                    0
        #define I3C_RESP_REG_RESP_REG_WIDTH                                  32
        #define I3C_RESP_REG_RESP_REG_MASK                                   0xffffffff
        #define I3C_RESP_REG_RESP_REG_RESET                                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_RESP_REG_RESP_REG_GET(value)                   (GAP_BEXTRACTU((value),32,0))
        #define I3C_RESP_REG_RESP_REG_GETS(value)                  (GAP_BEXTRACT((value),32,0))
        #define I3C_RESP_REG_RESP_REG_SET(value,field)             (GAP_BINSERT((value),(field),32,0))
        #define I3C_RESP_REG_RESP_REG(val)                         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int resp_reg        :32; // Response register. Contains values of the success/failure of the command, transaction ID of the completed command & remaining data (for write transfer) or received data length (for read transfer) or number of remaining slaves (for dynamic address command).
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_resp_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_resp_reg : public vp::reg_32
        {
        public:
            inline void resp_reg_set(uint32_t value);
            inline uint32_t resp_reg_get();
        };

|

.. _i3c_IBI_Resp_Reg:

IBI_Resp_Reg
""""""""""""

In-Band interrupt status, timestamping information present, dynamic address of the slave or Hot Join request.

.. table:: 

    +-----+---+----------+-----------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|   Name   |                                                            Description                                                            |
    +=====+===+==========+===================================================================================================================================+
    |7:0  |R  |DATA_LEN  |IBI Data length. Number of bytes in the IBI requests received.                                                                     |
    +-----+---+----------+-----------------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |IBI_ID    |IBI received ID. Contains slave address for IBI. Contains Hot Join ID for the Hot-Join IBI                                         |
    +-----+---+----------+-----------------------------------------------------------------------------------------------------------------------------------+
    |24:16|R/W|RESERVED_0|Reserved/Not used.                                                                                                                 |
    +-----+---+----------+-----------------------------------------------------------------------------------------------------------------------------------+
    |25   |R  |TS_PRESENT|IBI timestamp present for IBI : -1’b1 : IBI is timestamped -1’b0 : IBI is not timestamped                                          |
    +-----+---+----------+-----------------------------------------------------------------------------------------------------------------------------------+
    |30:26|R/W|RESERVED_5|Reserved/Not used.                                                                                                                 |
    +-----+---+----------+-----------------------------------------------------------------------------------------------------------------------------------+
    |31   |R  |IBI_STS   |IBI status. Indicates how the IBI is handled : -1’b0 : Indicates IBI is handled with ACK -1’b1 : Indicates IBI is handled with NACK|
    +-----+---+----------+-----------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // In-Band interrupt status, timestamping information present, dynamic address of the slave or Hot Join request.
                #define I3C_IBI_RESP_REG_OFFSET                  0x14

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_ibi_resp_reg_get(uint32_t base);
        static inline void i3c_ibi_resp_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // IBI Data length. Number of bytes in the IBI requests received. (access: R)
        #define I3C_IBI_RESP_REG_DATA_LEN_BIT                                0
        #define I3C_IBI_RESP_REG_DATA_LEN_WIDTH                              8
        #define I3C_IBI_RESP_REG_DATA_LEN_MASK                               0xff
        #define I3C_IBI_RESP_REG_DATA_LEN_RESET                              0x0
        
        // IBI received ID. Contains slave address for IBI. Contains Hot Join ID for the Hot-Join IBI (access: R)
        #define I3C_IBI_RESP_REG_IBI_ID_BIT                                  8
        #define I3C_IBI_RESP_REG_IBI_ID_WIDTH                                8
        #define I3C_IBI_RESP_REG_IBI_ID_MASK                                 0xff00
        #define I3C_IBI_RESP_REG_IBI_ID_RESET                                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_IBI_RESP_REG_RESERVED_0_BIT                              16
        #define I3C_IBI_RESP_REG_RESERVED_0_WIDTH                            9
        #define I3C_IBI_RESP_REG_RESERVED_0_MASK                             0x1ff0000
        #define I3C_IBI_RESP_REG_RESERVED_0_RESET                            0x0
        
        // IBI timestamp present for IBI : -1b1 : IBI is timestamped -1b0 : IBI is not timestamped (access: R)
        #define I3C_IBI_RESP_REG_TS_PRESENT_BIT                              25
        #define I3C_IBI_RESP_REG_TS_PRESENT_WIDTH                            1
        #define I3C_IBI_RESP_REG_TS_PRESENT_MASK                             0x2000000
        #define I3C_IBI_RESP_REG_TS_PRESENT_RESET                            0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_IBI_RESP_REG_RESERVED_5_BIT                              26
        #define I3C_IBI_RESP_REG_RESERVED_5_WIDTH                            5
        #define I3C_IBI_RESP_REG_RESERVED_5_MASK                             0x7c000000
        #define I3C_IBI_RESP_REG_RESERVED_5_RESET                            0x0
        
        // IBI status. Indicates how the IBI is handled : -1b0 : Indicates IBI is handled with ACK -1b1 : Indicates IBI is handled with NACK (access: R)
        #define I3C_IBI_RESP_REG_IBI_STS_BIT                                 31
        #define I3C_IBI_RESP_REG_IBI_STS_WIDTH                               1
        #define I3C_IBI_RESP_REG_IBI_STS_MASK                                0x80000000
        #define I3C_IBI_RESP_REG_IBI_STS_RESET                               0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_IBI_RESP_REG_DATA_LEN_GET(value)               (GAP_BEXTRACTU((value),8,0))
        #define I3C_IBI_RESP_REG_DATA_LEN_GETS(value)              (GAP_BEXTRACT((value),8,0))
        #define I3C_IBI_RESP_REG_DATA_LEN_SET(value,field)         (GAP_BINSERT((value),(field),8,0))
        #define I3C_IBI_RESP_REG_DATA_LEN(val)                     ((val) << 0)
        
        #define I3C_IBI_RESP_REG_IBI_ID_GET(value)                 (GAP_BEXTRACTU((value),8,8))
        #define I3C_IBI_RESP_REG_IBI_ID_GETS(value)                (GAP_BEXTRACT((value),8,8))
        #define I3C_IBI_RESP_REG_IBI_ID_SET(value,field)           (GAP_BINSERT((value),(field),8,8))
        #define I3C_IBI_RESP_REG_IBI_ID(val)                       ((val) << 8)
        
        #define I3C_IBI_RESP_REG_RESERVED_0_GET(value)             (GAP_BEXTRACTU((value),9,16))
        #define I3C_IBI_RESP_REG_RESERVED_0_GETS(value)            (GAP_BEXTRACT((value),9,16))
        #define I3C_IBI_RESP_REG_RESERVED_0_SET(value,field)       (GAP_BINSERT((value),(field),9,16))
        #define I3C_IBI_RESP_REG_RESERVED_0(val)                   ((val) << 16)
        
        #define I3C_IBI_RESP_REG_TS_PRESENT_GET(value)             (GAP_BEXTRACTU((value),1,25))
        #define I3C_IBI_RESP_REG_TS_PRESENT_GETS(value)            (GAP_BEXTRACT((value),1,25))
        #define I3C_IBI_RESP_REG_TS_PRESENT_SET(value,field)       (GAP_BINSERT((value),(field),1,25))
        #define I3C_IBI_RESP_REG_TS_PRESENT(val)                   ((val) << 25)
        
        #define I3C_IBI_RESP_REG_RESERVED_5_GET(value)             (GAP_BEXTRACTU((value),5,26))
        #define I3C_IBI_RESP_REG_RESERVED_5_GETS(value)            (GAP_BEXTRACT((value),5,26))
        #define I3C_IBI_RESP_REG_RESERVED_5_SET(value,field)       (GAP_BINSERT((value),(field),5,26))
        #define I3C_IBI_RESP_REG_RESERVED_5(val)                   ((val) << 26)
        
        #define I3C_IBI_RESP_REG_IBI_STS_GET(value)                (GAP_BEXTRACTU((value),1,31))
        #define I3C_IBI_RESP_REG_IBI_STS_GETS(value)               (GAP_BEXTRACT((value),1,31))
        #define I3C_IBI_RESP_REG_IBI_STS_SET(value,field)          (GAP_BINSERT((value),(field),1,31))
        #define I3C_IBI_RESP_REG_IBI_STS(val)                      ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int data_len        :8 ; // IBI Data length. Number of bytes in the IBI requests received.
            unsigned int ibi_id          :8 ; // IBI received ID. Contains slave address for IBI. Contains Hot Join ID for the Hot-Join IBI
            unsigned int reserved_0      :9 ; // Reserved/Not used.
            unsigned int ts_present      :1 ; // IBI timestamp present for IBI : -1b1 : IBI is timestamped -1b0 : IBI is not timestamped
            unsigned int reserved_5      :5 ; // Reserved/Not used.
            unsigned int ibi_sts         :1 ; // IBI status. Indicates how the IBI is handled : -1b0 : Indicates IBI is handled with ACK -1b1 : Indicates IBI is handled with NACK
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_ibi_resp_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_ibi_resp_reg : public vp::reg_32
        {
        public:
            inline void data_len_set(uint32_t value);
            inline uint32_t data_len_get();
            inline void ibi_id_set(uint32_t value);
            inline uint32_t ibi_id_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ts_present_set(uint32_t value);
            inline uint32_t ts_present_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void ibi_sts_set(uint32_t value);
            inline uint32_t ibi_sts_get();
        };

|

.. _i3c_IBI_Data_Reg:

IBI_Data_Reg
""""""""""""

Data received from the slave during the IBI process.

.. table:: 

    +-----+---+--------+---------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|  Name  |                                                     Description                                                     |
    +=====+===+========+=====================================================================================================================+
    |31:0 |R  |IBI_DATA|IBI Data. Data received during the IBI process is stored in FIFO and is sent out to the Software using this register.|
    +-----+---+--------+---------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Data received from the slave during the IBI process.
                #define I3C_IBI_DATA_REG_OFFSET                  0x18

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_ibi_data_reg_get(uint32_t base);
        static inline void i3c_ibi_data_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // IBI Data. Data received during the IBI process is stored in FIFO and is sent out to the Software using this register. (access: R)
        #define I3C_IBI_DATA_REG_IBI_DATA_BIT                                0
        #define I3C_IBI_DATA_REG_IBI_DATA_WIDTH                              32
        #define I3C_IBI_DATA_REG_IBI_DATA_MASK                               0xffffffff
        #define I3C_IBI_DATA_REG_IBI_DATA_RESET                              0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_IBI_DATA_REG_IBI_DATA_GET(value)               (GAP_BEXTRACTU((value),32,0))
        #define I3C_IBI_DATA_REG_IBI_DATA_GETS(value)              (GAP_BEXTRACT((value),32,0))
        #define I3C_IBI_DATA_REG_IBI_DATA_SET(value,field)         (GAP_BINSERT((value),(field),32,0))
        #define I3C_IBI_DATA_REG_IBI_DATA(val)                     ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int ibi_data        :32; // IBI Data. Data received during the IBI process is stored in FIFO and is sent out to the Software using this register.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_ibi_data_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_ibi_data_reg : public vp::reg_32
        {
        public:
            inline void ibi_data_set(uint32_t value);
            inline uint32_t ibi_data_get();
        };

|

.. _i3c_Data_RX_FIFO_Reg:

Data_RX_FIFO_Reg
""""""""""""""""

Received data FIFO (Data_RX_FIFO).

.. table:: 

    +-----+---+-------+------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W| Name  |                                                         Description                                                          |
    +=====+===+=======+==============================================================================================================================+
    |31:0 |R  |DATA_RX|All the Data received from the slave is stored in FIFO. On request by the software, the FIFO read and the values are provided.|
    +-----+---+-------+------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Received data FIFO (Data_RX_FIFO).
                #define I3C_DATA_RX_FIFO_REG_OFFSET              0x1c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_data_rx_fifo_reg_get(uint32_t base);
        static inline void i3c_data_rx_fifo_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // All the Data received from the slave is stored in FIFO. On request by the software, the FIFO read and the values are provided. (access: R)
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_BIT                             0
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_WIDTH                           32
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_MASK                            0xffffffff
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_RESET                           0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_GET(value)            (GAP_BEXTRACTU((value),32,0))
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_GETS(value)           (GAP_BEXTRACT((value),32,0))
        #define I3C_DATA_RX_FIFO_REG_DATA_RX_SET(value,field)      (GAP_BINSERT((value),(field),32,0))
        #define I3C_DATA_RX_FIFO_REG_DATA_RX(val)                  ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int data_rx         :32; // All the Data received from the slave is stored in FIFO. On request by the software, the FIFO read and the values are provided.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_data_rx_fifo_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_data_rx_fifo_reg : public vp::reg_32
        {
        public:
            inline void data_rx_set(uint32_t value);
            inline uint32_t data_rx_get();
        };

|

.. _i3c_Data_TX_FIFO_Reg:

Data_TX_FIFO_Reg
""""""""""""""""

Sending data FIFO (Data_TX_FIFO).

.. table:: 

    +-----+---+-------+--------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W| Name  |                                                       Description                                                        |
    +=====+===+=======+==========================================================================================================================+
    |31:0 |W  |DATA_TX|Write data to be sent from the Master to the slave. Software writes this register for sending the write data to the slave.|
    +-----+---+-------+--------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Sending data FIFO (Data_TX_FIFO).
                #define I3C_DATA_TX_FIFO_REG_OFFSET              0x20

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_data_tx_fifo_reg_get(uint32_t base);
        static inline void i3c_data_tx_fifo_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Write data to be sent from the Master to the slave. Software writes this register for sending the write data to the slave. (access: W)
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_BIT                             0
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_WIDTH                           32
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_MASK                            0xffffffff
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_RESET                           0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_GET(value)            (GAP_BEXTRACTU((value),32,0))
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_GETS(value)           (GAP_BEXTRACT((value),32,0))
        #define I3C_DATA_TX_FIFO_REG_DATA_TX_SET(value,field)      (GAP_BINSERT((value),(field),32,0))
        #define I3C_DATA_TX_FIFO_REG_DATA_TX(val)                  ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int data_tx         :32; // Write data to be sent from the Master to the slave. Software writes this register for sending the write data to the slave.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_data_tx_fifo_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_data_tx_fifo_reg : public vp::reg_32
        {
        public:
            inline void data_tx_set(uint32_t value);
            inline uint32_t data_tx_get();
        };

|

.. _i3c_IRQ_STATUS_Reg:

IRQ_STATUS_Reg
""""""""""""""

Status of the event happened during the transfer.

.. table:: 

    +-----+---+---------------------+--------------------------------------------------+
    |Bit #|R/W|        Name         |                   Description                    |
    +=====+===+=====================+==================================================+
    |    0|R  |RESP_DONE            |Indicates the response completion is done.        |
    +-----+---+---------------------+--------------------------------------------------+
    |    1|R  |DATA_TX_FIFO_FULL    |Indicates the Data Tx FIFO is full.               |
    +-----+---+---------------------+--------------------------------------------------+
    |    2|R  |DATA_TX_FIFO_EMPTY   |Indicates the Data Tx FIFO is empty.              |
    +-----+---+---------------------+--------------------------------------------------+
    |    3|R  |CMD_REQ_FIFO_FULL    |Indicates the command transfer request FIFO Full. |
    +-----+---+---------------------+--------------------------------------------------+
    |    4|R  |DATA_RX_FIFO_FULL    |Indicates the Data Rx FIFO Full.                  |
    +-----+---+---------------------+--------------------------------------------------+
    |    5|R  |RESP_COMPL           |Indicates the response completion FIFO is full.   |
    +-----+---+---------------------+--------------------------------------------------+
    |    6|R  |IBI_TRANSFER_DONE    |Indicates the IBI request is received from slave. |
    +-----+---+---------------------+--------------------------------------------------+
    |    7|R  |IBI_DATA_RX_FIFO_FULL|Indicates the IBI payload is full.                |
    +-----+---+---------------------+--------------------------------------------------+
    |    8|R  |RST_COMPLETION       |Indicates the Master controller issued soft reset.|
    +-----+---+---------------------+--------------------------------------------------+
    |31:9 |R/W|RESERVED_0           |Reserved/Not used.                                |
    +-----+---+---------------------+--------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Status of the event happened during the transfer.
                #define I3C_IRQ_STATUS_REG_OFFSET                0x30

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_irq_status_reg_get(uint32_t base);
        static inline void i3c_irq_status_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Indicates the response completion is done. (access: R)
        #define I3C_IRQ_STATUS_REG_RESP_DONE_BIT                             0
        #define I3C_IRQ_STATUS_REG_RESP_DONE_WIDTH                           1
        #define I3C_IRQ_STATUS_REG_RESP_DONE_MASK                            0x1
        #define I3C_IRQ_STATUS_REG_RESP_DONE_RESET                           0x0
        
        // Indicates the Data Tx FIFO is full. (access: R)
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_BIT                     1
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_WIDTH                   1
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_MASK                    0x2
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_RESET                   0x0
        
        // Indicates the Data Tx FIFO is empty. (access: R)
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_BIT                    2
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_WIDTH                  1
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_MASK                   0x4
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_RESET                  0x0
        
        // Indicates the command transfer request FIFO Full. (access: R)
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_BIT                     3
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_WIDTH                   1
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_MASK                    0x8
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_RESET                   0x0
        
        // Indicates the Data Rx FIFO Full. (access: R)
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_BIT                     4
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_WIDTH                   1
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_MASK                    0x10
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_RESET                   0x0
        
        // Indicates the response completion FIFO is full. (access: R)
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_BIT                            5
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_WIDTH                          1
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_MASK                           0x20
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_RESET                          0x0
        
        // Indicates the IBI request is received from slave. (access: R)
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_BIT                     6
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_WIDTH                   1
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_MASK                    0x40
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_RESET                   0x0
        
        // Indicates the IBI payload is full. (access: R)
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_BIT                 7
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_WIDTH               1
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_MASK                0x80
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_RESET               0x0
        
        // Indicates the Master controller issued soft reset. (access: R)
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_BIT                        8
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_WIDTH                      1
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_MASK                       0x100
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_RESET                      0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_IRQ_STATUS_REG_RESERVED_0_BIT                            9
        #define I3C_IRQ_STATUS_REG_RESERVED_0_WIDTH                          23
        #define I3C_IRQ_STATUS_REG_RESERVED_0_MASK                           0xfffffe00
        #define I3C_IRQ_STATUS_REG_RESERVED_0_RESET                          0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_IRQ_STATUS_REG_RESP_DONE_GET(value)            (GAP_BEXTRACTU((value),1,0))
        #define I3C_IRQ_STATUS_REG_RESP_DONE_GETS(value)           (GAP_BEXTRACT((value),1,0))
        #define I3C_IRQ_STATUS_REG_RESP_DONE_SET(value,field)      (GAP_BINSERT((value),(field),1,0))
        #define I3C_IRQ_STATUS_REG_RESP_DONE(val)                  ((val) << 0)
        
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_GET(value)    (GAP_BEXTRACTU((value),1,1))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_GETS(value)   (GAP_BEXTRACT((value),1,1))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL_SET(value,field) (GAP_BINSERT((value),(field),1,1))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_FULL(val)          ((val) << 1)
        
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_GET(value)   (GAP_BEXTRACTU((value),1,2))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_GETS(value)  (GAP_BEXTRACT((value),1,2))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY_SET(value,field) (GAP_BINSERT((value),(field),1,2))
        #define I3C_IRQ_STATUS_REG_DATA_TX_FIFO_EMPTY(val)         ((val) << 2)
        
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_GET(value)    (GAP_BEXTRACTU((value),1,3))
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_GETS(value)   (GAP_BEXTRACT((value),1,3))
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL_SET(value,field) (GAP_BINSERT((value),(field),1,3))
        #define I3C_IRQ_STATUS_REG_CMD_REQ_FIFO_FULL(val)          ((val) << 3)
        
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_GET(value)    (GAP_BEXTRACTU((value),1,4))
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_GETS(value)   (GAP_BEXTRACT((value),1,4))
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL_SET(value,field) (GAP_BINSERT((value),(field),1,4))
        #define I3C_IRQ_STATUS_REG_DATA_RX_FIFO_FULL(val)          ((val) << 4)
        
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_GET(value)           (GAP_BEXTRACTU((value),1,5))
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_GETS(value)          (GAP_BEXTRACT((value),1,5))
        #define I3C_IRQ_STATUS_REG_RESP_COMPL_SET(value,field)     (GAP_BINSERT((value),(field),1,5))
        #define I3C_IRQ_STATUS_REG_RESP_COMPL(val)                 ((val) << 5)
        
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_GET(value)    (GAP_BEXTRACTU((value),1,6))
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_GETS(value)   (GAP_BEXTRACT((value),1,6))
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE_SET(value,field) (GAP_BINSERT((value),(field),1,6))
        #define I3C_IRQ_STATUS_REG_IBI_TRANSFER_DONE(val)          ((val) << 6)
        
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_GET(value) (GAP_BEXTRACTU((value),1,7))
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_GETS(value) (GAP_BEXTRACT((value),1,7))
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL_SET(value,field) (GAP_BINSERT((value),(field),1,7))
        #define I3C_IRQ_STATUS_REG_IBI_DATA_RX_FIFO_FULL(val)      ((val) << 7)
        
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_GET(value)       (GAP_BEXTRACTU((value),1,8))
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_GETS(value)      (GAP_BEXTRACT((value),1,8))
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION_SET(value,field) (GAP_BINSERT((value),(field),1,8))
        #define I3C_IRQ_STATUS_REG_RST_COMPLETION(val)             ((val) << 8)
        
        #define I3C_IRQ_STATUS_REG_RESERVED_0_GET(value)           (GAP_BEXTRACTU((value),23,9))
        #define I3C_IRQ_STATUS_REG_RESERVED_0_GETS(value)          (GAP_BEXTRACT((value),23,9))
        #define I3C_IRQ_STATUS_REG_RESERVED_0_SET(value,field)     (GAP_BINSERT((value),(field),23,9))
        #define I3C_IRQ_STATUS_REG_RESERVED_0(val)                 ((val) << 9)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int resp_done       :1 ; // Indicates the response completion is done.
            unsigned int data_tx_fifo_full:1 ; // Indicates the Data Tx FIFO is full.
            unsigned int data_tx_fifo_empty:1 ; // Indicates the Data Tx FIFO is empty.
            unsigned int cmd_req_fifo_full:1 ; // Indicates the command transfer request FIFO Full.
            unsigned int data_rx_fifo_full:1 ; // Indicates the Data Rx FIFO Full.
            unsigned int resp_compl      :1 ; // Indicates the response completion FIFO is full.
            unsigned int ibi_transfer_done:1 ; // Indicates the IBI request is received from slave.
            unsigned int ibi_data_rx_fifo_full:1 ; // Indicates the IBI payload is full.
            unsigned int rst_completion  :1 ; // Indicates the Master controller issued soft reset.
            unsigned int reserved_0      :23; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_irq_status_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_irq_status_reg : public vp::reg_32
        {
        public:
            inline void resp_done_set(uint32_t value);
            inline uint32_t resp_done_get();
            inline void data_tx_fifo_full_set(uint32_t value);
            inline uint32_t data_tx_fifo_full_get();
            inline void data_tx_fifo_empty_set(uint32_t value);
            inline uint32_t data_tx_fifo_empty_get();
            inline void cmd_req_fifo_full_set(uint32_t value);
            inline uint32_t cmd_req_fifo_full_get();
            inline void data_rx_fifo_full_set(uint32_t value);
            inline uint32_t data_rx_fifo_full_get();
            inline void resp_compl_set(uint32_t value);
            inline uint32_t resp_compl_get();
            inline void ibi_transfer_done_set(uint32_t value);
            inline uint32_t ibi_transfer_done_get();
            inline void ibi_data_rx_fifo_full_set(uint32_t value);
            inline uint32_t ibi_data_rx_fifo_full_get();
            inline void rst_completion_set(uint32_t value);
            inline uint32_t rst_completion_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_TCAS_TIMER_Reg:

TCAS_TIMER_Reg
""""""""""""""

Timing for Clock after Start condition (TCAS) is the time (in Number of Reference clocks) after the start condition after which the SCL pin can go low.

.. table:: 

    +-----+---+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|   Name   |                                                                                                         Description                                                                                                          |
    +=====+===+==========+==============================================================================================================================================================================================================================+
    |31:0 |R/W|TCAS_TIMER|Timing of the SCL pin to go low after the start condition (Number of ref_clk). As per specification, Min time value is 38.4ns. For 100MHz ref clock, total 4 clock periods are required. So, the value of the register is 0x3.|
    +-----+---+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Timing for Clock after Start condition (TCAS) is the time (in Number of Reference clocks) after the start condition after which the SCL pin can go low.
                #define I3C_TCAS_TIMER_REG_OFFSET                0x40

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tcas_timer_reg_get(uint32_t base);
        static inline void i3c_tcas_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Timing of the SCL pin to go low after the start condition (Number of ref_clk). As per specification, Min time value is 38.4ns. For 100MHz ref clock, total 4 clock periods are required. So, the value of the register is 0x3. (access: R/W)
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_BIT                            0
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_WIDTH                          32
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_MASK                           0xffffffff
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_RESET                          0x3

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_GET(value)           (GAP_BEXTRACTU((value),32,0))
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_GETS(value)          (GAP_BEXTRACT((value),32,0))
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER_SET(value,field)     (GAP_BINSERT((value),(field),32,0))
        #define I3C_TCAS_TIMER_REG_TCAS_TIMER(val)                 ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tcas_timer      :32; // Timing of the SCL pin to go low after the start condition (Number of ref_clk). As per specification, Min time value is 38.4ns. For 100MHz ref clock, total 4 clock periods are required. So, the value of the register is 0x3.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tcas_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tcas_timer_reg : public vp::reg_32
        {
        public:
            inline void tcas_timer_set(uint32_t value);
            inline uint32_t tcas_timer_get();
        };

|

.. _i3c_TLOW_OD_TIMER_Reg:

TLOW_OD_TIMER_Reg
"""""""""""""""""

Low period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go high.

.. table:: 

    +-----+---+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name     |                                                                                                          Description                                                                                                          |
    +=====+===+=============+===============================================================================================================================================================================================================================+
    |4:0  |R/W|TLOW_OD_TIMER|Low period of the SCL clock pin (Number of ref_clk). As per specification, Min time value is 200ns + fall time of SDA signal. For 100MHz ref clock, total 24 clock periods are required. So, the value of the register is 0x23.|
    +-----+---+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:5 |R/W|RESERVED_0   |Reserved/Not used.                                                                                                                                                                                                             |
    +-----+---+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Low period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go high.
                #define I3C_TLOW_OD_TIMER_REG_OFFSET             0x44

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tlow_od_timer_reg_get(uint32_t base);
        static inline void i3c_tlow_od_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Low period of the SCL clock pin (Number of ref_clk). As per specification, Min time value is 200ns + fall time of SDA signal. For 100MHz ref clock, total 24 clock periods are required. So, the value of the register is 0x23. (access: R/W)
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_BIT                      0
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_WIDTH                    5
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_MASK                     0x1f
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_RESET                    0x23
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_BIT                         5
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_WIDTH                       27
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_MASK                        0xffffffe0
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_RESET                       0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_GET(value)     (GAP_BEXTRACTU((value),5,0))
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_GETS(value)    (GAP_BEXTRACT((value),5,0))
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER_SET(value,field) (GAP_BINSERT((value),(field),5,0))
        #define I3C_TLOW_OD_TIMER_REG_TLOW_OD_TIMER(val)           ((val) << 0)
        
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_GET(value)        (GAP_BEXTRACTU((value),27,5))
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_GETS(value)       (GAP_BEXTRACT((value),27,5))
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0_SET(value,field)  (GAP_BINSERT((value),(field),27,5))
        #define I3C_TLOW_OD_TIMER_REG_RESERVED_0(val)              ((val) << 5)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tlow_od_timer   :5 ; // Low period of the SCL clock pin (Number of ref_clk). As per specification, Min time value is 200ns + fall time of SDA signal. For 100MHz ref clock, total 24 clock periods are required. So, the value of the register is 0x23.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tlow_od_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tlow_od_timer_reg : public vp::reg_32
        {
        public:
            inline void tlow_od_timer_set(uint32_t value);
            inline uint32_t tlow_od_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_THIGH_OD_TIMER_Reg:

THIGH_OD_TIMER_Reg
""""""""""""""""""

High period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go low.

.. table:: 

    +-----+---+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|     Name     |                                                                                               Description                                                                                               |
    +=====+===+==============+=========================================================================================================================================================================================================+
    |4:0  |R/W|THIGH_OD_TIMER|High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods is allowed. So, the value of the register is 0x2.|
    +-----+---+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:5 |R/W|RESERVED_0    |Reserved/Not used.                                                                                                                                                                                       |
    +-----+---+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // High period of SCL pin in Open-Drain mode (in Number of Reference clock) after the SCL pin can go low.
                #define I3C_THIGH_OD_TIMER_REG_OFFSET            0x48

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_thigh_od_timer_reg_get(uint32_t base);
        static inline void i3c_thigh_od_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods is allowed. So, the value of the register is 0x2. (access: R/W)
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_BIT                    0
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_WIDTH                  5
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_MASK                   0x1f
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_RESET                  0x2
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_BIT                        5
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_WIDTH                      27
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_MASK                       0xffffffe0
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_RESET                      0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_GET(value)   (GAP_BEXTRACTU((value),5,0))
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_GETS(value)  (GAP_BEXTRACT((value),5,0))
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER_SET(value,field) (GAP_BINSERT((value),(field),5,0))
        #define I3C_THIGH_OD_TIMER_REG_THIGH_OD_TIMER(val)         ((val) << 0)
        
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_GET(value)       (GAP_BEXTRACTU((value),27,5))
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_GETS(value)      (GAP_BEXTRACT((value),27,5))
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),27,5))
        #define I3C_THIGH_OD_TIMER_REG_RESERVED_0(val)             ((val) << 5)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int thigh_od_timer  :5 ; // High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods is allowed. So, the value of the register is 0x2.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thigh_od_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_thigh_od_timer_reg : public vp::reg_32
        {
        public:
            inline void thigh_od_timer_set(uint32_t value);
            inline uint32_t thigh_od_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_TLOW_PP_TIMER_Reg:

TLOW_PP_TIMER_Reg
"""""""""""""""""

Low period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go high.

.. table:: 

    +-----+---+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name     |                                                                                                    Description                                                                                                     |
    +=====+===+=============+====================================================================================================================================================================================================================+
    |4:0  |R/W|TLOW_PP_TIMER|Low period of the SCL clock pin (Number of ref_clk) in Push pull mode. As per specification, Min time value is 24ns. For 100MHz ref clock, total 3 clock periods are required. So, the value of the register is 0x3.|
    +-----+---+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:5 |R/W|RESERVED_0   |Reserved/Not used.                                                                                                                                                                                                  |
    +-----+---+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Low period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go high.
                #define I3C_TLOW_PP_TIMER_REG_OFFSET             0x4c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tlow_pp_timer_reg_get(uint32_t base);
        static inline void i3c_tlow_pp_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Low period of the SCL clock pin (Number of ref_clk) in Push pull mode. As per specification, Min time value is 24ns. For 100MHz ref clock, total 3 clock periods are required. So, the value of the register is 0x3. (access: R/W)
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_BIT                      0
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_WIDTH                    5
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_MASK                     0x1f
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_RESET                    0x3
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_BIT                         5
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_WIDTH                       27
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_MASK                        0xffffffe0
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_RESET                       0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_GET(value)     (GAP_BEXTRACTU((value),5,0))
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_GETS(value)    (GAP_BEXTRACT((value),5,0))
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER_SET(value,field) (GAP_BINSERT((value),(field),5,0))
        #define I3C_TLOW_PP_TIMER_REG_TLOW_PP_TIMER(val)           ((val) << 0)
        
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_GET(value)        (GAP_BEXTRACTU((value),27,5))
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_GETS(value)       (GAP_BEXTRACT((value),27,5))
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0_SET(value,field)  (GAP_BINSERT((value),(field),27,5))
        #define I3C_TLOW_PP_TIMER_REG_RESERVED_0(val)              ((val) << 5)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tlow_pp_timer   :5 ; // Low period of the SCL clock pin (Number of ref_clk) in Push pull mode. As per specification, Min time value is 24ns. For 100MHz ref clock, total 3 clock periods are required. So, the value of the register is 0x3.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tlow_pp_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tlow_pp_timer_reg : public vp::reg_32
        {
        public:
            inline void tlow_pp_timer_set(uint32_t value);
            inline uint32_t tlow_pp_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_THIGH_PP_TIMER_Reg:

THIGH_PP_TIMER_Reg
""""""""""""""""""

High period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go low.

.. table:: 

    +-----+---+--------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|     Name     |                                                                                                Description                                                                                                |
    +=====+===+==============+===========================================================================================================================================================================================================+
    |4:0  |R/W|THIGH_PP_TIMER|High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods are required. So, the value of the register is 0x2.|
    +-----+---+--------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:5 |R/W|RESERVED_0    |Reserved/Not used.                                                                                                                                                                                         |
    +-----+---+--------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // High period of SCL pin in Push-Pull mode (in Number of Reference clock) after the SCL pin can go low.
                #define I3C_THIGH_PP_TIMER_REG_OFFSET            0x50

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_thigh_pp_timer_reg_get(uint32_t base);
        static inline void i3c_thigh_pp_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods are required. So, the value of the register is 0x2. (access: R/W)
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_BIT                    0
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_WIDTH                  5
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_MASK                   0x1f
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_RESET                  0x2
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_BIT                        5
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_WIDTH                      27
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_MASK                       0xffffffe0
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_RESET                      0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_GET(value)   (GAP_BEXTRACTU((value),5,0))
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_GETS(value)  (GAP_BEXTRACT((value),5,0))
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER_SET(value,field) (GAP_BINSERT((value),(field),5,0))
        #define I3C_THIGH_PP_TIMER_REG_THIGH_PP_TIMER(val)         ((val) << 0)
        
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_GET(value)       (GAP_BEXTRACTU((value),27,5))
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_GETS(value)      (GAP_BEXTRACT((value),27,5))
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),27,5))
        #define I3C_THIGH_PP_TIMER_REG_RESERVED_0(val)             ((val) << 5)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int thigh_pp_timer  :5 ; // High period of the SCL clock pin (Number of ref_clk). As per specification, Max time value is 41ns. For 100MHz ref clock, Max. of total 4 clock periods are required. So, the value of the register is 0x2.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thigh_pp_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_thigh_pp_timer_reg : public vp::reg_32
        {
        public:
            inline void thigh_pp_timer_set(uint32_t value);
            inline uint32_t thigh_pp_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_TDS_TIMER_Reg:

TDS_TIMER_Reg
"""""""""""""

SDA data setup time during both Open-Drain/Push-Pull mode (in Number of Reference clock).

.. table:: 

    +-----+---+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|   Name   |                                                                                      Description                                                                                      |
    +=====+===+==========+=======================================================================================================================================================================================+
    |2:0  |R/W|TDS_TIMER |SDA Set up time (Number of ref_clk). As per specification, Min time value is 3ns. For 100MHz ref clock, Max. of total 1 clock period is required. So, the value of the register is 0x1.|
    +-----+---+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:3 |R/W|RESERVED_0|Reserved/Not used.                                                                                                                                                                     |
    +-----+---+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // SDA data setup time during both Open-Drain/Push-Pull mode (in Number of Reference clock).
                #define I3C_TDS_TIMER_REG_OFFSET                 0x54

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tds_timer_reg_get(uint32_t base);
        static inline void i3c_tds_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // SDA Set up time (Number of ref_clk). As per specification, Min time value is 3ns. For 100MHz ref clock, Max. of total 1 clock period is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_TDS_TIMER_REG_TDS_TIMER_BIT                              0
        #define I3C_TDS_TIMER_REG_TDS_TIMER_WIDTH                            3
        #define I3C_TDS_TIMER_REG_TDS_TIMER_MASK                             0x7
        #define I3C_TDS_TIMER_REG_TDS_TIMER_RESET                            0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TDS_TIMER_REG_RESERVED_0_BIT                             3
        #define I3C_TDS_TIMER_REG_RESERVED_0_WIDTH                           29
        #define I3C_TDS_TIMER_REG_RESERVED_0_MASK                            0xfffffff8
        #define I3C_TDS_TIMER_REG_RESERVED_0_RESET                           0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TDS_TIMER_REG_TDS_TIMER_GET(value)             (GAP_BEXTRACTU((value),3,0))
        #define I3C_TDS_TIMER_REG_TDS_TIMER_GETS(value)            (GAP_BEXTRACT((value),3,0))
        #define I3C_TDS_TIMER_REG_TDS_TIMER_SET(value,field)       (GAP_BINSERT((value),(field),3,0))
        #define I3C_TDS_TIMER_REG_TDS_TIMER(val)                   ((val) << 0)
        
        #define I3C_TDS_TIMER_REG_RESERVED_0_GET(value)            (GAP_BEXTRACTU((value),29,3))
        #define I3C_TDS_TIMER_REG_RESERVED_0_GETS(value)           (GAP_BEXTRACT((value),29,3))
        #define I3C_TDS_TIMER_REG_RESERVED_0_SET(value,field)      (GAP_BINSERT((value),(field),29,3))
        #define I3C_TDS_TIMER_REG_RESERVED_0(val)                  ((val) << 3)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tds_timer       :3 ; // SDA Set up time (Number of ref_clk). As per specification, Min time value is 3ns. For 100MHz ref clock, Max. of total 1 clock period is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tds_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tds_timer_reg : public vp::reg_32
        {
        public:
            inline void tds_timer_set(uint32_t value);
            inline uint32_t tds_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_THD_PP_TIMER_Reg:

THD_PP_TIMER_Reg
""""""""""""""""

SDA data hold time during the Push-Pull mode (in Number of Reference clock).

.. table:: 

    +-----+---+------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                     Description                                                                                     |
    +=====+===+============+=====================================================================================================================================================================================+
    |2:0  |R/W|THD_PP_TIMER|SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1.|
    +-----+---+------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:3 |R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                   |
    +-----+---+------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // SDA data hold time during the Push-Pull mode (in Number of Reference clock).
                #define I3C_THD_PP_TIMER_REG_OFFSET              0x58

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_thd_pp_timer_reg_get(uint32_t base);
        static inline void i3c_thd_pp_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_BIT                        0
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_WIDTH                      3
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_MASK                       0x7
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_RESET                      0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_BIT                          3
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_WIDTH                        29
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_MASK                         0xfffffff8
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_RESET                        0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_GET(value)       (GAP_BEXTRACTU((value),3,0))
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_GETS(value)      (GAP_BEXTRACT((value),3,0))
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER_SET(value,field) (GAP_BINSERT((value),(field),3,0))
        #define I3C_THD_PP_TIMER_REG_THD_PP_TIMER(val)             ((val) << 0)
        
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_GET(value)         (GAP_BEXTRACTU((value),29,3))
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_GETS(value)        (GAP_BEXTRACT((value),29,3))
        #define I3C_THD_PP_TIMER_REG_RESERVED_0_SET(value,field)   (GAP_BINSERT((value),(field),29,3))
        #define I3C_THD_PP_TIMER_REG_RESERVED_0(val)               ((val) << 3)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int thd_pp_timer    :3 ; // SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thd_pp_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_thd_pp_timer_reg : public vp::reg_32
        {
        public:
            inline void thd_pp_timer_set(uint32_t value);
            inline uint32_t thd_pp_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_TCBP_TIMER_Reg:

TCBP_TIMER_Reg
""""""""""""""

Clock time before Stop condition.

.. table:: 

    +-----+---+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|   Name   |                                                                                                                                Description                                                                                                                                 |
    +=====+===+==========+============================================================================================================================================================================================================================================================================+
    |4:0  |R/W|TCBP_TIMER|To signal STOP condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1.|
    +-----+---+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:5 |R/W|RESERVED_0|Reserved/Not used.                                                                                                                                                                                                                                                          |
    +-----+---+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Clock time before Stop condition.
                #define I3C_TCBP_TIMER_REG_OFFSET                0x5c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tcbp_timer_reg_get(uint32_t base);
        static inline void i3c_tcbp_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // To signal STOP condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_BIT                            0
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_WIDTH                          5
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_MASK                           0x1f
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_RESET                          0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TCBP_TIMER_REG_RESERVED_0_BIT                            5
        #define I3C_TCBP_TIMER_REG_RESERVED_0_WIDTH                          27
        #define I3C_TCBP_TIMER_REG_RESERVED_0_MASK                           0xffffffe0
        #define I3C_TCBP_TIMER_REG_RESERVED_0_RESET                          0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_GET(value)           (GAP_BEXTRACTU((value),5,0))
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_GETS(value)          (GAP_BEXTRACT((value),5,0))
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER_SET(value,field)     (GAP_BINSERT((value),(field),5,0))
        #define I3C_TCBP_TIMER_REG_TCBP_TIMER(val)                 ((val) << 0)
        
        #define I3C_TCBP_TIMER_REG_RESERVED_0_GET(value)           (GAP_BEXTRACTU((value),27,5))
        #define I3C_TCBP_TIMER_REG_RESERVED_0_GETS(value)          (GAP_BEXTRACT((value),27,5))
        #define I3C_TCBP_TIMER_REG_RESERVED_0_SET(value,field)     (GAP_BINSERT((value),(field),27,5))
        #define I3C_TCBP_TIMER_REG_RESERVED_0(val)                 ((val) << 5)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tcbp_timer      :5 ; // To signal STOP condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :27; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tcbp_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tcbp_timer_reg : public vp::reg_32
        {
        public:
            inline void tcbp_timer_set(uint32_t value);
            inline uint32_t tcbp_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_TCBSR_TIMER_Reg:

TCBSR_TIMER_Reg
"""""""""""""""

Clock time before Repeated start condition.

.. table:: 

    +-----+---+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|   Name    |                                                                                                                                     Description                                                                                                                                      |
    +=====+===+===========+======================================================================================================================================================================================================================================================================================+
    |2:0  |R/W|TCBSR_TIMER|To signal Repeated start condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1.|
    +-----+---+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:3 |R/W|RESERVED_0 |Reserved/Not used.                                                                                                                                                                                                                                                                    |
    +-----+---+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Clock time before Repeated start condition.
                #define I3C_TCBSR_TIMER_REG_OFFSET               0x60

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tcbsr_timer_reg_get(uint32_t base);
        static inline void i3c_tcbsr_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // To signal Repeated start condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_BIT                          0
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_WIDTH                        3
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_MASK                         0x7
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_RESET                        0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_BIT                           3
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_WIDTH                         29
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_MASK                          0xfffffff8
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_RESET                         0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_GET(value)         (GAP_BEXTRACTU((value),3,0))
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_GETS(value)        (GAP_BEXTRACT((value),3,0))
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER_SET(value,field)   (GAP_BINSERT((value),(field),3,0))
        #define I3C_TCBSR_TIMER_REG_TCBSR_TIMER(val)               ((val) << 0)
        
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_GET(value)          (GAP_BEXTRACTU((value),29,3))
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_GETS(value)         (GAP_BEXTRACT((value),29,3))
        #define I3C_TCBSR_TIMER_REG_RESERVED_0_SET(value,field)    (GAP_BINSERT((value),(field),29,3))
        #define I3C_TCBSR_TIMER_REG_RESERVED_0(val)                ((val) << 3)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tcbsr_timer     :3 ; // To signal Repeated start condition, the master should change the SDA pin after this time of SCL clock edge (Number of ref_clk). As per specification, Min time value is 19.2ns. For 100MHz ref clock, Max. of total 2 clock periods is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tcbsr_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tcbsr_timer_reg : public vp::reg_32
        {
        public:
            inline void tcbsr_timer_set(uint32_t value);
            inline uint32_t tcbsr_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_THD_DDR_TIMER_Reg:

THD_DDR_TIMER_Reg
"""""""""""""""""

SDA data hold time during the Push-Pull mode (in Number of Reference clock) in DDR Data rate.

.. table:: 

    +-----+---+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name     |                                                                                     Description                                                                                     |
    +=====+===+=============+=====================================================================================================================================================================================+
    |2:0  |R/W|THD_DDR_TIMER|SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1.|
    +-----+---+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:3 |R/W|RESERVED_0   |Reserved/Not used.                                                                                                                                                                   |
    +-----+---+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // SDA data hold time during the Push-Pull mode (in Number of Reference clock) in DDR Data rate.
                #define I3C_THD_DDR_TIMER_REG_OFFSET             0x64

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_thd_ddr_timer_reg_get(uint32_t base);
        static inline void i3c_thd_ddr_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1. (access: R/W)
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_BIT                      0
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_WIDTH                    3
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_MASK                     0x7
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_RESET                    0x1
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_BIT                         3
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_WIDTH                       29
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_MASK                        0xfffffff8
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_RESET                       0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_GET(value)     (GAP_BEXTRACTU((value),3,0))
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_GETS(value)    (GAP_BEXTRACT((value),3,0))
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER_SET(value,field) (GAP_BINSERT((value),(field),3,0))
        #define I3C_THD_DDR_TIMER_REG_THD_DDR_TIMER(val)           ((val) << 0)
        
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_GET(value)        (GAP_BEXTRACTU((value),29,3))
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_GETS(value)       (GAP_BEXTRACT((value),29,3))
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0_SET(value,field)  (GAP_BINSERT((value),(field),29,3))
        #define I3C_THD_DDR_TIMER_REG_RESERVED_0(val)              ((val) << 3)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int thd_ddr_timer   :3 ; // SDA Hold time (Number of ref_clk). As per specification, Min time value is 6ns. For 100MHz ref clock, Min. of total 1 clock period is required. So, the value of the register is 0x1.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thd_ddr_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_thd_ddr_timer_reg : public vp::reg_32
        {
        public:
            inline void thd_ddr_timer_set(uint32_t value);
            inline uint32_t thd_ddr_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_BUS_FREE_TIMER_Reg:

BUS_FREE_TIMER_Reg
""""""""""""""""""

Bus free time between the Stop condition and the next start condition (in Number of Reference clock).

.. table:: 

    +-----+---+--------------+-----------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|     Name     |                                                      Description                                                      |
    +=====+===+==============+=======================================================================================================================+
    |31:0 |R/W|BUS_FREE_TIMER|Bus free time after the STOP condition and the Start condition. As per specification, Min. value of this period is 1us.|
    +-----+---+--------------+-----------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Bus free time between the Stop condition and the next start condition (in Number of Reference clock).
                #define I3C_BUS_FREE_TIMER_REG_OFFSET            0x68

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_bus_free_timer_reg_get(uint32_t base);
        static inline void i3c_bus_free_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Bus free time after the STOP condition and the Start condition. As per specification, Min. value of this period is 1us. (access: R/W)
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_BIT                    0
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_WIDTH                  32
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_MASK                   0xffffffff
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_RESET                  0x200

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_BUS_FREE_TIMER_REG_BUS_FREE_TIMER(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int bus_free_timer  :32; // Bus free time after the STOP condition and the Start condition. As per specification, Min. value of this period is 1us.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_bus_free_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_bus_free_timer_reg : public vp::reg_32
        {
        public:
            inline void bus_free_timer_set(uint32_t value);
            inline uint32_t bus_free_timer_get();
        };

|

.. _i3c_BUS_AVAIL_TIMER_Reg:

BUS_AVAIL_TIMER_Reg
"""""""""""""""""""

Time to keep the SDA and SCL pin to High (in Number of Reference clock).

.. table:: 

    +-----+---+---------------+-------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|     Name      |                                              Description                                              |
    +=====+===+===============+=======================================================================================================+
    |31:0 |R/W|BUS_AVAIL_TIMER|Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1us.|
    +-----+---+---------------+-------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Time to keep the SDA and SCL pin to High (in Number of Reference clock).
                #define I3C_BUS_AVAIL_TIMER_REG_OFFSET           0x6c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_bus_avail_timer_reg_get(uint32_t base);
        static inline void i3c_bus_avail_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1us. (access: R/W)
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_BIT                  0
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_WIDTH                32
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_MASK                 0xffffffff
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_RESET                0x200

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_BUS_AVAIL_TIMER_REG_BUS_AVAIL_TIMER(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int bus_avail_timer :32; // Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1us.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_bus_avail_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_bus_avail_timer_reg : public vp::reg_32
        {
        public:
            inline void bus_avail_timer_set(uint32_t value);
            inline uint32_t bus_avail_timer_get();
        };

|

.. _i3c_TIDLE_TIMER_Reg:

TIDLE_TIMER_Reg
"""""""""""""""

Extended duration of the bus free condition after the Stop condition (in Number of Reference clock) to enable the device to drive the Hot Join request.

.. table:: 

    +-----+---+-----------+-------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|   Name    |                                              Description                                              |
    +=====+===+===========+=======================================================================================================+
    |31:0 |R/W|TIDLE_TIMER|Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1ms.|
    +-----+---+-----------+-------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Extended duration of the bus free condition after the Stop condition (in Number of Reference clock) to enable the device to drive the Hot Join request.
                #define I3C_TIDLE_TIMER_REG_OFFSET               0x70

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tidle_timer_reg_get(uint32_t base);
        static inline void i3c_tidle_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1ms. (access: R/W)
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_BIT                          0
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_WIDTH                        32
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_MASK                         0xffffffff
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_RESET                        0x200

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_GET(value)         (GAP_BEXTRACTU((value),32,0))
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_GETS(value)        (GAP_BEXTRACT((value),32,0))
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER_SET(value,field)   (GAP_BINSERT((value),(field),32,0))
        #define I3C_TIDLE_TIMER_REG_TIDLE_TIMER(val)               ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tidle_timer     :32; // Bus aval time to drive SCL and SDA pin to high. As per specification, Min. value of this period is 1ms.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tidle_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tidle_timer_reg : public vp::reg_32
        {
        public:
            inline void tidle_timer_set(uint32_t value);
            inline uint32_t tidle_timer_get();
        };

|

.. _i3c_TSCO_TIMER_Reg:

TSCO_TIMER_Reg
""""""""""""""

Maximum time the slave needs to drive the bus during the ACK/read data after the clock change.

.. table:: 

    +-----+---+----------+-----------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|   Name   |                                                Description                                                |
    +=====+===+==========+===========================================================================================================+
    |2:0  |R/W|TSCO_TIMER|Maximum time for the slave to release bus after the clock change. As per specification, Max. value is 12ns.|
    +-----+---+----------+-----------------------------------------------------------------------------------------------------------+
    |31:3 |R/W|RESERVED_0|Reserved/Not used.                                                                                         |
    +-----+---+----------+-----------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Maximum time the slave needs to drive the bus during the ACK/read data after the clock change.
                #define I3C_TSCO_TIMER_REG_OFFSET                0x74

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tsco_timer_reg_get(uint32_t base);
        static inline void i3c_tsco_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Maximum time for the slave to release bus after the clock change. As per specification, Max. value is 12ns. (access: R/W)
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_BIT                            0
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_WIDTH                          3
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_MASK                           0x7
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_RESET                          0x2
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TSCO_TIMER_REG_RESERVED_0_BIT                            3
        #define I3C_TSCO_TIMER_REG_RESERVED_0_WIDTH                          29
        #define I3C_TSCO_TIMER_REG_RESERVED_0_MASK                           0xfffffff8
        #define I3C_TSCO_TIMER_REG_RESERVED_0_RESET                          0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_GET(value)           (GAP_BEXTRACTU((value),3,0))
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_GETS(value)          (GAP_BEXTRACT((value),3,0))
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER_SET(value,field)     (GAP_BINSERT((value),(field),3,0))
        #define I3C_TSCO_TIMER_REG_TSCO_TIMER(val)                 ((val) << 0)
        
        #define I3C_TSCO_TIMER_REG_RESERVED_0_GET(value)           (GAP_BEXTRACTU((value),29,3))
        #define I3C_TSCO_TIMER_REG_RESERVED_0_GETS(value)          (GAP_BEXTRACT((value),29,3))
        #define I3C_TSCO_TIMER_REG_RESERVED_0_SET(value,field)     (GAP_BINSERT((value),(field),29,3))
        #define I3C_TSCO_TIMER_REG_RESERVED_0(val)                 ((val) << 3)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tsco_timer      :3 ; // Maximum time for the slave to release bus after the clock change. As per specification, Max. value is 12ns.
            unsigned int reserved_0      :29; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tsco_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tsco_timer_reg : public vp::reg_32
        {
        public:
            inline void tsco_timer_set(uint32_t value);
            inline uint32_t tsco_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_TSU_STA_TIMER_Reg:

TSU_STA_TIMER_Reg
"""""""""""""""""

SDA data setup time during both Open-Drain (in Number of Reference clock) for a Repeated Start.

.. table:: 

    +-----+---+-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name     |                                                                                                                                                                                   Description                                                                                                                                                                                    |
    +=====+===+=============+==================================================================================================================================================================================================================================================================================================================================================================================+
    |8:0  |R/W|TSU_STA_TIMER|SDA Set up time (Number of ref_clk) for a Repeated Start during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.|
    +-----+---+-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:9 |R/W|RESERVED_0   |Reserved/Not used.                                                                                                                                                                                                                                                                                                                                                                |
    +-----+---+-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // SDA data setup time during both Open-Drain (in Number of Reference clock) for a Repeated Start.
                #define I3C_TSU_STA_TIMER_REG_OFFSET             0x90

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tsu_sta_timer_reg_get(uint32_t base);
        static inline void i3c_tsu_sta_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // SDA Set up time (Number of ref_clk) for a Repeated Start during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_BIT                      0
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_WIDTH                    9
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_MASK                     0x1ff
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_RESET                    0x46
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_BIT                         9
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_WIDTH                       23
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_MASK                        0xfffffe00
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_RESET                       0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_GET(value)     (GAP_BEXTRACTU((value),9,0))
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_GETS(value)    (GAP_BEXTRACT((value),9,0))
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER_SET(value,field) (GAP_BINSERT((value),(field),9,0))
        #define I3C_TSU_STA_TIMER_REG_TSU_STA_TIMER(val)           ((val) << 0)
        
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_GET(value)        (GAP_BEXTRACTU((value),23,9))
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_GETS(value)       (GAP_BEXTRACT((value),23,9))
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0_SET(value,field)  (GAP_BINSERT((value),(field),23,9))
        #define I3C_TSU_STA_TIMER_REG_RESERVED_0(val)              ((val) << 9)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tsu_sta_timer   :9 ; // SDA Set up time (Number of ref_clk) for a Repeated Start during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
            unsigned int reserved_0      :23; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tsu_sta_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tsu_sta_timer_reg : public vp::reg_32
        {
        public:
            inline void tsu_sta_timer_set(uint32_t value);
            inline uint32_t tsu_sta_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_THD_STA_TIMER_Reg:

THD_STA_TIMER_Reg
"""""""""""""""""

SDA data hold time during the Open Drain mode (in Number of Reference clock).

.. table:: 

    +-----+---+-------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name     |                                                                                                                                                                          Description                                                                                                                                                                          |
    +=====+===+=============+===============================================================================================================================================================================================================================================================================================================================================================+
    |8:0  |R/W|THD_STA_TIMER|SDA Hold time (Number of ref_clk) after Start/Repeated Start. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.|
    +-----+---+-------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // SDA data hold time during the Open Drain mode (in Number of Reference clock).
                #define I3C_THD_STA_TIMER_REG_OFFSET             0x94

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_thd_sta_timer_reg_get(uint32_t base);
        static inline void i3c_thd_sta_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // SDA Hold time (Number of ref_clk) after Start/Repeated Start. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_BIT                      0
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_WIDTH                    9
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_MASK                     0x1ff
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_RESET                    0x46

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_GET(value)     (GAP_BEXTRACTU((value),9,0))
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_GETS(value)    (GAP_BEXTRACT((value),9,0))
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER_SET(value,field) (GAP_BINSERT((value),(field),9,0))
        #define I3C_THD_STA_TIMER_REG_THD_STA_TIMER(val)           ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int thd_sta_timer   :9 ; // SDA Hold time (Number of ref_clk) after Start/Repeated Start. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thd_sta_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_thd_sta_timer_reg : public vp::reg_32
        {
        public:
            inline void thd_sta_timer_set(uint32_t value);
            inline uint32_t thd_sta_timer_get();
        };

|

.. _i3c_TLOW_TIMER_Reg:

TLOW_TIMER_Reg
""""""""""""""

Low period of SCL pin in Open Drain mode during Legacy I2c Mode (in Number of Reference clock) after the timer reached the SCL pin can go high.

.. table:: 

    +-----+---+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|   Name   |                                                                                                                                                                                Description                                                                                                                                                                                |
    +=====+===+==========+===========================================================================================================================================================================================================================================================================================================================================================================+
    |15:0 |R/W|TLOW_TIMER|Low period of the SCL clock pin (Number of ref_clk) in Legacy I2C Mode. As per specification, Min time value is 1300ns for Legacy FM Mode. As per specification, Min time value is 500ns for Legacy FM+ Mode. For 100MHz ref clock, total 130 clock periods are required. For FM Mode, the value of the register is 0x8C. For FM+ Mode, the value of this register is 0x3c.|
    +-----+---+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                                                                                                                                                                                                                                                                                                                                         |
    +-----+---+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Low period of SCL pin in Open Drain mode during Legacy I2c Mode (in Number of Reference clock) after the timer reached the SCL pin can go high.
                #define I3C_TLOW_TIMER_REG_OFFSET                0x98

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tlow_timer_reg_get(uint32_t base);
        static inline void i3c_tlow_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Low period of the SCL clock pin (Number of ref_clk) in Legacy I2C Mode. As per specification, Min time value is 1300ns for Legacy FM Mode. As per specification, Min time value is 500ns for Legacy FM+ Mode. For 100MHz ref clock, total 130 clock periods are required. For FM Mode, the value of the register is 0x8C. For FM+ Mode, the value of this register is 0x3c. (access: R/W)
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_BIT                            0
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_WIDTH                          16
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_MASK                           0xffff
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_RESET                          0x8c
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TLOW_TIMER_REG_RESERVED_0_BIT                            16
        #define I3C_TLOW_TIMER_REG_RESERVED_0_WIDTH                          16
        #define I3C_TLOW_TIMER_REG_RESERVED_0_MASK                           0xffff0000
        #define I3C_TLOW_TIMER_REG_RESERVED_0_RESET                          0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_GET(value)           (GAP_BEXTRACTU((value),16,0))
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_GETS(value)          (GAP_BEXTRACT((value),16,0))
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER_SET(value,field)     (GAP_BINSERT((value),(field),16,0))
        #define I3C_TLOW_TIMER_REG_TLOW_TIMER(val)                 ((val) << 0)
        
        #define I3C_TLOW_TIMER_REG_RESERVED_0_GET(value)           (GAP_BEXTRACTU((value),16,16))
        #define I3C_TLOW_TIMER_REG_RESERVED_0_GETS(value)          (GAP_BEXTRACT((value),16,16))
        #define I3C_TLOW_TIMER_REG_RESERVED_0_SET(value,field)     (GAP_BINSERT((value),(field),16,16))
        #define I3C_TLOW_TIMER_REG_RESERVED_0(val)                 ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tlow_timer      :16; // Low period of the SCL clock pin (Number of ref_clk) in Legacy I2C Mode. As per specification, Min time value is 1300ns for Legacy FM Mode. As per specification, Min time value is 500ns for Legacy FM+ Mode. For 100MHz ref clock, total 130 clock periods are required. For FM Mode, the value of the register is 0x8C. For FM+ Mode, the value of this register is 0x3c.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tlow_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tlow_timer_reg : public vp::reg_32
        {
        public:
            inline void tlow_timer_set(uint32_t value);
            inline uint32_t tlow_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_THIGH_TIMER_Reg:

THIGH_TIMER_Reg
"""""""""""""""

High period of SCL pin in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SCL pin can go low.

.. table:: 

    +-----+---+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|   Name    |                                                                                                                                                                               Description                                                                                                                                                                                |
    +=====+===+===========+==========================================================================================================================================================================================================================================================================================================================================================================+
    |15:0 |R/W|THIGH_TIMER|High period of the SCL clock pin (Number of ref_clk) in Legacy I2C mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.|
    +-----+---+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:16|R/W|RESERVED_0 |Reserved/Not used.                                                                                                                                                                                                                                                                                                                                                        |
    +-----+---+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // High period of SCL pin in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SCL pin can go low.
                #define I3C_THIGH_TIMER_REG_OFFSET               0x9c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_thigh_timer_reg_get(uint32_t base);
        static inline void i3c_thigh_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // High period of the SCL clock pin (Number of ref_clk) in Legacy I2C mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_BIT                          0
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_WIDTH                        16
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_MASK                         0xffff
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_RESET                        0x46
        
        // Reserved/Not used. (access: R/W)
        #define I3C_THIGH_TIMER_REG_RESERVED_0_BIT                           16
        #define I3C_THIGH_TIMER_REG_RESERVED_0_WIDTH                         16
        #define I3C_THIGH_TIMER_REG_RESERVED_0_MASK                          0xffff0000
        #define I3C_THIGH_TIMER_REG_RESERVED_0_RESET                         0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_GET(value)         (GAP_BEXTRACTU((value),16,0))
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_GETS(value)        (GAP_BEXTRACT((value),16,0))
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER_SET(value,field)   (GAP_BINSERT((value),(field),16,0))
        #define I3C_THIGH_TIMER_REG_THIGH_TIMER(val)               ((val) << 0)
        
        #define I3C_THIGH_TIMER_REG_RESERVED_0_GET(value)          (GAP_BEXTRACTU((value),16,16))
        #define I3C_THIGH_TIMER_REG_RESERVED_0_GETS(value)         (GAP_BEXTRACT((value),16,16))
        #define I3C_THIGH_TIMER_REG_RESERVED_0_SET(value,field)    (GAP_BINSERT((value),(field),16,16))
        #define I3C_THIGH_TIMER_REG_RESERVED_0(val)                ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int thigh_timer     :16; // High period of the SCL clock pin (Number of ref_clk) in Legacy I2C mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_thigh_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_thigh_timer_reg : public vp::reg_32
        {
        public:
            inline void thigh_timer_set(uint32_t value);
            inline uint32_t thigh_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_TVD_DATA_TIMER_Reg:

TVD_DATA_TIMER_Reg
""""""""""""""""""

Data hold time in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SDA pin can change its value.

.. table:: 

    +-----+---+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|     Name     |                                                                                                                                                                                                                                                              Description                                                                                                                                                                                                                                                              |
    +=====+===+==============+=======================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================+
    |9:0  |R/W|TVD_DATA_TIMER|Data Hold time (Number of ref_clk) in Legacy I2C mode. As per specification, Min Data setup time value is 100ns for Legacy FM Mode. So, hold time will be min 600 ns, so that the Legacy system works correctly. As per specification, Min Data setup time value is 50ns for Legacy FM+ Mode. So, hold time will be min 260 ns, so that the Legacy system works correctly. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.|
    +-----+---+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:10|R/W|RESERVED_0    |Reserved/Not used.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
    +-----+---+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Data hold time in Open Drain Mode for Legacy I2C (in Number of Reference clock) after this timer count reached the SDA pin can change its value.
                #define I3C_TVD_DATA_TIMER_REG_OFFSET            0xa0

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tvd_data_timer_reg_get(uint32_t base);
        static inline void i3c_tvd_data_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Data Hold time (Number of ref_clk) in Legacy I2C mode. As per specification, Min Data setup time value is 100ns for Legacy FM Mode. So, hold time will be min 600 ns, so that the Legacy system works correctly. As per specification, Min Data setup time value is 50ns for Legacy FM+ Mode. So, hold time will be min 260 ns, so that the Legacy system works correctly. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_BIT                    0
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_WIDTH                  10
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_MASK                   0x3ff
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_RESET                  0x46
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_BIT                        10
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_WIDTH                      22
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_MASK                       0xfffffc00
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_RESET                      0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_GET(value)   (GAP_BEXTRACTU((value),10,0))
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_GETS(value)  (GAP_BEXTRACT((value),10,0))
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER_SET(value,field) (GAP_BINSERT((value),(field),10,0))
        #define I3C_TVD_DATA_TIMER_REG_TVD_DATA_TIMER(val)         ((val) << 0)
        
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_GET(value)       (GAP_BEXTRACTU((value),22,10))
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_GETS(value)      (GAP_BEXTRACT((value),22,10))
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),22,10))
        #define I3C_TVD_DATA_TIMER_REG_RESERVED_0(val)             ((val) << 10)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tvd_data_timer  :10; // Data Hold time (Number of ref_clk) in Legacy I2C mode. As per specification, Min Data setup time value is 100ns for Legacy FM Mode. So, hold time will be min 600 ns, so that the Legacy system works correctly. As per specification, Min Data setup time value is 50ns for Legacy FM+ Mode. So, hold time will be min 260 ns, so that the Legacy system works correctly. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
            unsigned int reserved_0      :22; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tvd_data_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tvd_data_timer_reg : public vp::reg_32
        {
        public:
            inline void tvd_data_timer_set(uint32_t value);
            inline uint32_t tvd_data_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_TSU_STOP_TIMER_Reg:

TSU_STOP_TIMER_Reg
""""""""""""""""""

SDA data setup time during Open-Drain (in Number of Reference clock) for Stop condition.

.. table:: 

    +-----+---+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|     Name     |                                                                                                                                                                                  Description                                                                                                                                                                                   |
    +=====+===+==============+================================================================================================================================================================================================================================================================================================================================================================================+
    |8:0  |R/W|TSU_STOP_TIMER|SDA Set up time (Number of ref_clk) for Stop condition during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.|
    +-----+---+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31:9 |R/W|RESERVED_0    |Reserved/Not used.                                                                                                                                                                                                                                                                                                                                                              |
    +-----+---+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // SDA data setup time during Open-Drain (in Number of Reference clock) for Stop condition.
                #define I3C_TSU_STOP_TIMER_REG_OFFSET            0xa8

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_tsu_stop_timer_reg_get(uint32_t base);
        static inline void i3c_tsu_stop_timer_reg_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // SDA Set up time (Number of ref_clk) for Stop condition during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E. (access: R/W)
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_BIT                    0
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_WIDTH                  9
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_MASK                   0x1ff
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_RESET                  0x46
        
        // Reserved/Not used. (access: R/W)
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_BIT                        9
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_WIDTH                      23
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_MASK                       0xfffffe00
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_RESET                      0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_GET(value)   (GAP_BEXTRACTU((value),9,0))
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_GETS(value)  (GAP_BEXTRACT((value),9,0))
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER_SET(value,field) (GAP_BINSERT((value),(field),9,0))
        #define I3C_TSU_STOP_TIMER_REG_TSU_STOP_TIMER(val)         ((val) << 0)
        
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_GET(value)       (GAP_BEXTRACTU((value),23,9))
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_GETS(value)      (GAP_BEXTRACT((value),23,9))
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),23,9))
        #define I3C_TSU_STOP_TIMER_REG_RESERVED_0(val)             ((val) << 9)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int tsu_stop_timer  :9 ; // SDA Set up time (Number of ref_clk) for Stop condition during Legacy I2C Mode. As per specification, Min time value is 600ns for Legacy FM Mode. As per specification, Min time value is 260ns for Legacy FM+ Mode. For 100MHz ref clock, total 70 clock periods are required. For FM Mode, the value of the register is 0x46. For FM+ Mode, the value of this register is 0x1E.
            unsigned int reserved_0      :23; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_tsu_stop_timer_reg_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_tsu_stop_timer_reg : public vp::reg_32
        {
        public:
            inline void tsu_stop_timer_set(uint32_t value);
            inline uint32_t tsu_stop_timer_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
        };

|

.. _i3c_Device_Addr_Table_Reg0:

Device_Addr_Table_Reg0
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave0.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave0.
                #define I3C_DEVICE_ADDR_TABLE_REG0_OFFSET        0x100

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg0_get(uint32_t base);
        static inline void i3c_device_addr_table_reg0_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG0_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG0_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG0_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG0_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG0_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg0_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg0 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg1:

Device_Addr_Table_Reg1
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave1.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave1.
                #define I3C_DEVICE_ADDR_TABLE_REG1_OFFSET        0x104

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg1_get(uint32_t base);
        static inline void i3c_device_addr_table_reg1_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG1_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG1_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG1_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG1_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG1_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg1_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg1 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg2:

Device_Addr_Table_Reg2
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave2.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave2.
                #define I3C_DEVICE_ADDR_TABLE_REG2_OFFSET        0x108

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg2_get(uint32_t base);
        static inline void i3c_device_addr_table_reg2_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG2_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG2_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG2_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG2_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG2_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg2_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg2 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg3:

Device_Addr_Table_Reg3
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave3.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave3.
                #define I3C_DEVICE_ADDR_TABLE_REG3_OFFSET        0x10c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg3_get(uint32_t base);
        static inline void i3c_device_addr_table_reg3_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG3_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG3_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG3_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG3_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG3_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg3_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg3 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg4:

Device_Addr_Table_Reg4
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave4.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave4.
                #define I3C_DEVICE_ADDR_TABLE_REG4_OFFSET        0x110

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg4_get(uint32_t base);
        static inline void i3c_device_addr_table_reg4_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG4_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG4_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG4_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG4_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG4_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg4_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg4 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg5:

Device_Addr_Table_Reg5
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave5.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave5.
                #define I3C_DEVICE_ADDR_TABLE_REG5_OFFSET        0x114

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg5_get(uint32_t base);
        static inline void i3c_device_addr_table_reg5_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG5_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG5_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG5_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG5_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG5_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg5_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg5 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg6:

Device_Addr_Table_Reg6
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave6.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave6.
                #define I3C_DEVICE_ADDR_TABLE_REG6_OFFSET        0x118

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg6_get(uint32_t base);
        static inline void i3c_device_addr_table_reg6_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG6_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG6_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG6_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG6_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG6_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg6_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg6 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg7:

Device_Addr_Table_Reg7
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave7.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave7.
                #define I3C_DEVICE_ADDR_TABLE_REG7_OFFSET        0x11c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg7_get(uint32_t base);
        static inline void i3c_device_addr_table_reg7_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG7_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG7_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG7_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG7_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG7_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg7_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg7 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg8:

Device_Addr_Table_Reg8
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave8.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave8.
                #define I3C_DEVICE_ADDR_TABLE_REG8_OFFSET        0x120

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg8_get(uint32_t base);
        static inline void i3c_device_addr_table_reg8_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG8_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG8_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG8_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG8_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG8_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg8_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg8 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg9:

Device_Addr_Table_Reg9
""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave9.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave9.
                #define I3C_DEVICE_ADDR_TABLE_REG9_OFFSET        0x124

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg9_get(uint32_t base);
        static inline void i3c_device_addr_table_reg9_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_BIT                   0
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_MASK                  0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_BIT                    24
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_WIDTH                  7
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_MASK                   0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_RESET                  0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_BIT                   12
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_MASK                  0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_RESET                 0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_BIT                   13
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_MASK                  0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_RESET                 0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_BIT                    14
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_MASK                   0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_RESET                  0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_BIT                     15
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_WIDTH                   1
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_MASK                    0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_RESET                   0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_BIT                  16
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_WIDTH                8
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_MASK                 0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_RESET                0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_BIT                   31
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_MASK                  0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_GET(value)  (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG9_STATIC_ADDR(val)        ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_GET(value)   (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_GETS(value)  (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_0(val)         ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_GET(value)  (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IBI_PAYLOAD(val)        ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_GET(value)  (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG9_IN_BAND_REQ(val)        ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_GET(value)   (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_GETS(value)  (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG9_RESERVED_5(val)         ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_GET(value)    (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_GETS(value)   (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG9_TIMESTAMP(val)          ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DYNAMIC_ADDR(val)       ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_GET(value)  (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG9_DEVICE_TYPE(val)        ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg9_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg9 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg10:

Device_Addr_Table_Reg10
"""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave10.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave10.
                #define I3C_DEVICE_ADDR_TABLE_REG10_OFFSET       0x128

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg10_get(uint32_t base);
        static inline void i3c_device_addr_table_reg10_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_BIT                  0
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_WIDTH                7
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_MASK                 0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_BIT                   24
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_MASK                  0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_RESET                 0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_BIT                  12
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_MASK                 0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_RESET                0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_BIT                  13
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_MASK                 0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_BIT                   14
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_MASK                  0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_RESET                 0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_BIT                    15
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_MASK                   0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_RESET                  0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_BIT                 16
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_WIDTH               8
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_MASK                0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_RESET               0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_BIT                  31
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_MASK                 0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_GET(value) (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG10_STATIC_ADDR(val)       ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_GET(value)  (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_0(val)        ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_GET(value) (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IBI_PAYLOAD(val)       ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_GET(value) (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG10_IN_BAND_REQ(val)       ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_GET(value)  (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_GETS(value) (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG10_RESERVED_5(val)        ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_GET(value)   (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_GETS(value)  (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG10_TIMESTAMP(val)         ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DYNAMIC_ADDR(val)      ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_GET(value) (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG10_DEVICE_TYPE(val)       ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg10_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg10 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Addr_Table_Reg11:

Device_Addr_Table_Reg11
"""""""""""""""""""""""

Device type, IBI handling and Dynamic address to be set and Static address of the slave11.

.. table:: 

    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                                                      Description                                                                                       |
    +=====+===+============+========================================================================================================================================================================================+
    |6:0  |R/W|Static_Addr |Device Static address. I3C/I2C static address                                                                                                                                           |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |30:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |12   |R/W|IBI_Payload |IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1’b0 : No IBI data payload - 1’b1 : IBI data contains payload|
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |13   |R/W|In_Band_Req |In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |14   |R/W|RESERVED_5  |Reserved/Not used.                                                                                                                                                                      |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |15   |R/W|Timestamp   |Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1’b0 : Timestamp not required - 1’b1 : Timestamp enabled                                             |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |23:16|R/W|Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave                                                                |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |31   |R/W|Device_Type |Device type : - 1’b0 : I3C Device - 1’b1 : I2C Device                                                                                                                                   |
    +-----+---+------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // Device type, IBI handling and Dynamic address to be set and Static address of the slave11.
                #define I3C_DEVICE_ADDR_TABLE_REG11_OFFSET       0x12c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_addr_table_reg11_get(uint32_t base);
        static inline void i3c_device_addr_table_reg11_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Static address. I3C/I2C static address (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_BIT                  0
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_WIDTH                7
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_MASK                 0x7f
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_BIT                   24
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_WIDTH                 7
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_MASK                  0x7f000000
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_RESET                 0x0
        
        // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_BIT                  12
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_MASK                 0x1000
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_RESET                0x0
        
        // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_BIT                  13
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_MASK                 0x2000
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_RESET                0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_BIT                   14
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_WIDTH                 1
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_MASK                  0x4000
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_RESET                 0x0
        
        // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_BIT                    15
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_WIDTH                  1
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_MASK                   0x8000
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_RESET                  0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_BIT                 16
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_WIDTH               8
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_MASK                0xff0000
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_RESET               0x0
        
        // Device type : - 1b0 : I3C Device - 1b1 : I2C Device (access: R/W)
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_BIT                  31
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_WIDTH                1
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_MASK                 0x80000000
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_GET(value) (GAP_BEXTRACTU((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_GETS(value) (GAP_BEXTRACT((value),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),7,0))
        #define I3C_DEVICE_ADDR_TABLE_REG11_STATIC_ADDR(val)       ((val) << 0)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_GET(value)  (GAP_BEXTRACTU((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),7,24))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_0(val)        ((val) << 24)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_GET(value) (GAP_BEXTRACTU((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_GETS(value) (GAP_BEXTRACT((value),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD_SET(value,field) (GAP_BINSERT((value),(field),1,12))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IBI_PAYLOAD(val)       ((val) << 12)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_GET(value) (GAP_BEXTRACTU((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_GETS(value) (GAP_BEXTRACT((value),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ_SET(value,field) (GAP_BINSERT((value),(field),1,13))
        #define I3C_DEVICE_ADDR_TABLE_REG11_IN_BAND_REQ(val)       ((val) << 13)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_GET(value)  (GAP_BEXTRACTU((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_GETS(value) (GAP_BEXTRACT((value),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5_SET(value,field) (GAP_BINSERT((value),(field),1,14))
        #define I3C_DEVICE_ADDR_TABLE_REG11_RESERVED_5(val)        ((val) << 14)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_GET(value)   (GAP_BEXTRACTU((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_GETS(value)  (GAP_BEXTRACT((value),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP_SET(value,field) (GAP_BINSERT((value),(field),1,15))
        #define I3C_DEVICE_ADDR_TABLE_REG11_TIMESTAMP(val)         ((val) << 15)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DYNAMIC_ADDR(val)      ((val) << 16)
        
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_GET(value) (GAP_BEXTRACTU((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_GETS(value) (GAP_BEXTRACT((value),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE_SET(value,field) (GAP_BINSERT((value),(field),1,31))
        #define I3C_DEVICE_ADDR_TABLE_REG11_DEVICE_TYPE(val)       ((val) << 31)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int static_addr     :7 ; // Device Static address. I3C/I2C static address
            unsigned int padding0:17;
            unsigned int reserved_0      :7 ; // Reserved/Not used.
            unsigned int ibi_payload     :1 ; // IBI payload. This bit reflects the information from the BCR regarding the IBI data present to be received by the Master: - 1b0 : No IBI data payload - 1b1 : IBI data contains payload
            unsigned int in_band_req     :1 ; // In-band interrupt enable. Controls the master to ACK/NACK the IBI requests from the particular slave.
            unsigned int reserved_5      :1 ; // Reserved/Not used.
            unsigned int timestamp       :1 ; // Device IBI timestamp. Enables or disables timestamping for a particular Device : - 1b0 : Timestamp not required - 1b1 : Timestamp enabled
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int padding1:7 ;
            unsigned int device_type     :1 ; // Device type : - 1b0 : I3C Device - 1b1 : I2C Device
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_addr_table_reg11_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_addr_table_reg11 : public vp::reg_32
        {
        public:
            inline void static_addr_set(uint32_t value);
            inline uint32_t static_addr_get();
            inline void reserved_0_set(uint32_t value);
            inline uint32_t reserved_0_get();
            inline void ibi_payload_set(uint32_t value);
            inline uint32_t ibi_payload_get();
            inline void in_band_req_set(uint32_t value);
            inline uint32_t in_band_req_get();
            inline void reserved_5_set(uint32_t value);
            inline uint32_t reserved_5_get();
            inline void timestamp_set(uint32_t value);
            inline uint32_t timestamp_get();
            inline void dynamic_addr_set(uint32_t value);
            inline uint32_t dynamic_addr_get();
            inline void device_type_set(uint32_t value);
            inline uint32_t device_type_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_0:

Device_Char_Table_Reg0_0
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_0_OFFSET      0x200

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_0_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_0_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_RESET                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_0_PID_HIGH(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_0_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_0 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_0:

Device_Char_Table_Reg1_0
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_0_OFFSET      0x204

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_0_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_0_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_0_RESERVED_0(val)       ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_0_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_0 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_0:

Device_Char_Table_Reg2_0
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_0_OFFSET      0x208

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_0_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_0_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_0_RESERVED_0(val)       ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_0_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_0 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_0:

Device_Char_Table_Reg3_0
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave0 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_0_OFFSET      0x20c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_0_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_0_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_0_RESERVED_0(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_0_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_0 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_1:

Device_Char_Table_Reg0_1
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----+-----------+
    |Bit #|R/W|Name|Description|
    +=====+===+====+===========+
    +-----+---+----+-----------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_1_OFFSET      0x210

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_1_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_1_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c


.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c


.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_1_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_1 : public vp::reg_128
        {
        public:
        };

|

.. _i3c_Device_Char_Table_Reg1_1:

Device_Char_Table_Reg1_1
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----+-----------+
    |Bit #|R/W|Name|Description|
    +=====+===+====+===========+
    +-----+---+----+-----------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_1_OFFSET      0x214

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_1_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_1_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c


.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c


.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_1_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_1 : public vp::reg_128
        {
        public:
        };

|

.. _i3c_Device_Char_Table_Reg2_1:

Device_Char_Table_Reg2_1
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----+-----------+
    |Bit #|R/W|Name|Description|
    +=====+===+====+===========+
    +-----+---+----+-----------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_1_OFFSET      0x218

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_1_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_1_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c


.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c


.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_1_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_1 : public vp::reg_128
        {
        public:
        };

|

.. _i3c_Device_Char_Table_Reg3_1:

Device_Char_Table_Reg3_1
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----+-----------+
    |Bit #|R/W|Name|Description|
    +=====+===+====+===========+
    +-----+---+----+-----------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave1 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_1_OFFSET      0x21c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_1_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_1_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c


.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c


.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_1_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_1 : public vp::reg_128
        {
        public:
        };

|

.. _i3c_Device_Char_Table_Reg0_2:

Device_Char_Table_Reg0_2
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_2_OFFSET      0x220

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_2_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_2_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_RESET                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_2_PID_HIGH(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_2_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_2 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_2:

Device_Char_Table_Reg1_2
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_2_OFFSET      0x224

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_2_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_2_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_2_RESERVED_0(val)       ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_2_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_2 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_2:

Device_Char_Table_Reg2_2
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_2_OFFSET      0x228

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_2_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_2_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_2_RESERVED_0(val)       ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_2_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_2 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_2:

Device_Char_Table_Reg3_2
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave2 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_2_OFFSET      0x22c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_2_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_2_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_2_RESERVED_0(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_2_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_2 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_3:

Device_Char_Table_Reg0_3
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_3_OFFSET      0x230

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_3_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_3_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_RESET                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_3_PID_HIGH(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_3_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_3 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_3:

Device_Char_Table_Reg1_3
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_3_OFFSET      0x234

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_3_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_3_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_3_RESERVED_0(val)       ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_3_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_3 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_3:

Device_Char_Table_Reg2_3
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_3_OFFSET      0x238

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_3_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_3_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_3_RESERVED_0(val)       ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_3_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_3 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_3:

Device_Char_Table_Reg3_3
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave3 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_3_OFFSET      0x23c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_3_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_3_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_3_RESERVED_0(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_3_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_3 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_4:

Device_Char_Table_Reg0_4
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_4_OFFSET      0x240

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_4_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_4_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_RESET                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_4_PID_HIGH(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_4_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_4 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_4:

Device_Char_Table_Reg1_4
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_4_OFFSET      0x244

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_4_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_4_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_4_RESERVED_0(val)       ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_4_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_4 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_4:

Device_Char_Table_Reg2_4
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_4_OFFSET      0x248

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_4_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_4_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_4_RESERVED_0(val)       ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_4_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_4 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_4:

Device_Char_Table_Reg3_4
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave4 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_4_OFFSET      0x24c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_4_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_4_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_4_RESERVED_0(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_4_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_4 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_5:

Device_Char_Table_Reg0_5
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_5_OFFSET      0x250

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_5_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_5_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_RESET                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_5_PID_HIGH(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_5_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_5 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_5:

Device_Char_Table_Reg1_5
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_5_OFFSET      0x254

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_5_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_5_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_5_RESERVED_0(val)       ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_5_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_5 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_5:

Device_Char_Table_Reg2_5
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_5_OFFSET      0x258

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_5_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_5_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_5_RESERVED_0(val)       ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_5_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_5 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_5:

Device_Char_Table_Reg3_5
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave5 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_5_OFFSET      0x25c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_5_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_5_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_5_RESERVED_0(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_5_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_5 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_6:

Device_Char_Table_Reg0_6
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_6_OFFSET      0x260

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_6_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_6_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_RESET                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_6_PID_HIGH(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_6_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_6 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_6:

Device_Char_Table_Reg1_6
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_6_OFFSET      0x264

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_6_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_6_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_6_RESERVED_0(val)       ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_6_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_6 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_6:

Device_Char_Table_Reg2_6
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_6_OFFSET      0x268

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_6_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_6_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_6_RESERVED_0(val)       ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_6_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_6 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_6:

Device_Char_Table_Reg3_6
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave6 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_6_OFFSET      0x26c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_6_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_6_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_6_RESERVED_0(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_6_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_6 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_7:

Device_Char_Table_Reg0_7
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_7_OFFSET      0x270

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_7_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_7_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_RESET                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_7_PID_HIGH(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_7_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_7 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_7:

Device_Char_Table_Reg1_7
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_7_OFFSET      0x274

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_7_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_7_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_7_RESERVED_0(val)       ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_7_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_7 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_7:

Device_Char_Table_Reg2_7
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_7_OFFSET      0x278

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_7_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_7_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_7_RESERVED_0(val)       ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_7_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_7 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_7:

Device_Char_Table_Reg3_7
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave7 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_7_OFFSET      0x27c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_7_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_7_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_7_RESERVED_0(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_7_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_7 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_8:

Device_Char_Table_Reg0_8
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_8_OFFSET      0x280

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_8_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_8_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_RESET                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_8_PID_HIGH(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_8_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_8 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_8:

Device_Char_Table_Reg1_8
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_8_OFFSET      0x284

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_8_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_8_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_8_RESERVED_0(val)       ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_8_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_8 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_8:

Device_Char_Table_Reg2_8
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_8_OFFSET      0x288

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_8_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_8_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_8_RESERVED_0(val)       ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_8_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_8 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_8:

Device_Char_Table_Reg3_8
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave8 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_8_OFFSET      0x28c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_8_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_8_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_8_RESERVED_0(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_8_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_8 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_9:

Device_Char_Table_Reg0_9
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_9_OFFSET      0x290

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_9_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_9_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_WIDTH                  32
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_MASK                   0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_RESET                  0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_GET(value)   (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_GETS(value)  (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_9_PID_HIGH(val)         ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_9_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_9 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_9:

Device_Char_Table_Reg1_9
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_9_OFFSET      0x294

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_9_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_9_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_BIT                     0
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_WIDTH                   16
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_MASK                    0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_RESET                   0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_BIT                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_WIDTH                16
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_MASK                 0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_GET(value)    (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_GETS(value)   (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_PID_LOW(val)          ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_9_RESERVED_0(val)       ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_9_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_9 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_9:

Device_Char_Table_Reg2_9
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_9_OFFSET      0x298

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_9_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_9_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_BIT                         0
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_MASK                        0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_RESET                       0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_BIT                         8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_WIDTH                       8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_MASK                        0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_RESET                       0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_BIT                16
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_WIDTH              8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_MASK               0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_RESET              0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_BIT                  24
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_WIDTH                8
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_MASK                 0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_GET(value)        (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_GETS(value)       (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR_SET(value,field)  (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DCR(val)              ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_GET(value)        (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_GETS(value)       (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR_SET(value,field)  (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_BCR(val)              ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_DYNAMIC_ADDR(val)     ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_9_RESERVED_0(val)       ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_9_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_9 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_9:

Device_Char_Table_Reg3_9
""""""""""""""""""""""""

BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave9 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_9_OFFSET      0x29c

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_9_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_9_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_BIT                  0
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_WIDTH                32
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_MASK                 0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_RESET                0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_9_RESERVED_0(val)       ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_9_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_9 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_10:

Device_Char_Table_Reg0_10
"""""""""""""""""""""""""

BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_10_OFFSET     0x2a0

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_10_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_10_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_BIT                   0
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_WIDTH                 32
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_MASK                  0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_GET(value)  (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_10_PID_HIGH(val)        ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_10_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_10 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_10:

Device_Char_Table_Reg1_10
"""""""""""""""""""""""""

BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_10_OFFSET     0x2a4

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_10_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_10_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_WIDTH                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_MASK                   0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_RESET                  0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_BIT                 16
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_WIDTH               16
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_MASK                0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_RESET               0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_GET(value)   (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_GETS(value)  (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_PID_LOW(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_10_RESERVED_0(val)      ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_10_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_10 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_10:

Device_Char_Table_Reg2_10
"""""""""""""""""""""""""

BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_10_OFFSET     0x2a8

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_10_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_10_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_BIT                        0
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_WIDTH                      8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_MASK                       0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_RESET                      0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_BIT                        8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_WIDTH                      8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_MASK                       0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_RESET                      0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_BIT               16
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_WIDTH             8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_MASK              0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_RESET             0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_BIT                 24
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_WIDTH               8
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_MASK                0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_RESET               0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_GET(value)       (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_GETS(value)      (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR_SET(value,field) (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DCR(val)             ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_GET(value)       (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_GETS(value)      (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR_SET(value,field) (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_BCR(val)             ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_DYNAMIC_ADDR(val)    ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_10_RESERVED_0(val)      ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_10_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_10 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_10:

Device_Char_Table_Reg3_10
"""""""""""""""""""""""""

BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave10 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_10_OFFSET     0x2ac

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_10_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_10_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_BIT                 0
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_WIDTH               32
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_MASK                0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_RESET               0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_10_RESERVED_0(val)      ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_10_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_10 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg0_11:

Device_Char_Table_Reg0_11
"""""""""""""""""""""""""

BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.

.. table:: 

    +-----+---+--------+--------------------------------------------------------------+
    |Bit #|R/W|  Name  |                         Description                          |
    +=====+===+========+==============================================================+
    |31:0 |R  |PID_HIGH|Device provisional ID high : bits [48:16] of Device’s I3C PID.|
    +-----+---+--------+--------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG0_11_OFFSET     0x2b0

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg0_11_get(uint32_t base);
        static inline void i3c_device_char_table_reg0_11_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID high : bits [48:16] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_BIT                   0
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_WIDTH                 32
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_MASK                  0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_RESET                 0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_GET(value)  (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG0_11_PID_HIGH(val)        ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_high        :32; // Device provisional ID high : bits [48:16] of Devices I3C PID.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg0_11_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg0_11 : public vp::reg_128
        {
        public:
            inline void pid_high_set(uint128_t value);
            inline uint128_t pid_high_get();
        };

|

.. _i3c_Device_Char_Table_Reg1_11:

Device_Char_Table_Reg1_11
"""""""""""""""""""""""""

BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------------------------------------------------+
    |Bit #|R/W|   Name   |                        Description                         |
    +=====+===+==========+============================================================+
    |15:0 |R  |PID_LOW   |Device provisional ID low : bits [15:0] of Device’s I3C PID.|
    +-----+---+----------+------------------------------------------------------------+
    |31:16|R/W|RESERVED_0|Reserved/Not used.                                          |
    +-----+---+----------+------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG1_11_OFFSET     0x2b4

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg1_11_get(uint32_t base);
        static inline void i3c_device_char_table_reg1_11_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device provisional ID low : bits [15:0] of Devices I3C PID. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_BIT                    0
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_WIDTH                  16
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_MASK                   0xffff
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_RESET                  0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_BIT                 16
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_WIDTH               16
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_MASK                0xffff0000
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_RESET               0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_GET(value)   (GAP_BEXTRACTU((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_GETS(value)  (GAP_BEXTRACT((value),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW_SET(value,field) (GAP_BINSERT((value),(field),16,0))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_PID_LOW(val)         ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),16,16))
        #define I3C_DEVICE_CHAR_TABLE_REG1_11_RESERVED_0(val)      ((val) << 16)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int pid_low         :16; // Device provisional ID low : bits [15:0] of Devices I3C PID.
            unsigned int reserved_0      :16; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg1_11_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg1_11 : public vp::reg_128
        {
        public:
            inline void pid_low_set(uint128_t value);
            inline uint128_t pid_low_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg2_11:

Device_Char_Table_Reg2_11
"""""""""""""""""""""""""

BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.

.. table:: 

    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |Bit #|R/W|    Name    |                                                      Description                                                       |
    +=====+===+============+========================================================================================================================+
    |7:0  |R  |DCR         |Device Characteristics Register(DCR) of the slave.                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |15:8 |R  |BCR         |I3C Bus Characteristics Register(BCR) of the slave.                                                                     |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |23:16|R  |Dynamic_Addr|Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16 – Address of the slave|
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+
    |31:24|R/W|RESERVED_0  |Reserved/Not used.                                                                                                      |
    +-----+---+------------+------------------------------------------------------------------------------------------------------------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG2_11_OFFSET     0x2b8

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg2_11_get(uint32_t base);
        static inline void i3c_device_char_table_reg2_11_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Device Characteristics Register(DCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_BIT                        0
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_WIDTH                      8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_MASK                       0xff
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_RESET                      0x0
        
        // I3C Bus Characteristics Register(BCR) of the slave. (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_BIT                        8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_WIDTH                      8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_MASK                       0xff00
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_RESET                      0x0
        
        // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave (access: R)
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_BIT               16
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_WIDTH             8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_MASK              0xff0000
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_RESET             0x0
        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_BIT                 24
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_WIDTH               8
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_MASK                0xff000000
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_RESET               0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_GET(value)       (GAP_BEXTRACTU((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_GETS(value)      (GAP_BEXTRACT((value),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR_SET(value,field) (GAP_BINSERT((value),(field),8,0))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DCR(val)             ((val) << 0)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_GET(value)       (GAP_BEXTRACTU((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_GETS(value)      (GAP_BEXTRACT((value),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR_SET(value,field) (GAP_BINSERT((value),(field),8,8))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_BCR(val)             ((val) << 8)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_GET(value) (GAP_BEXTRACTU((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_GETS(value) (GAP_BEXTRACT((value),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR_SET(value,field) (GAP_BINSERT((value),(field),8,16))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_DYNAMIC_ADDR(val)    ((val) << 16)
        
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),8,24))
        #define I3C_DEVICE_CHAR_TABLE_REG2_11_RESERVED_0(val)      ((val) << 24)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int dcr             :8 ; // Device Characteristics Register(DCR) of the slave.
            unsigned int bcr             :8 ; // I3C Bus Characteristics Register(BCR) of the slave.
            unsigned int dynamic_addr    :8 ; // Device I3C Dynamic address. 23 - Parity bit for the dynamic address calculated by software. 22:16  Address of the slave
            unsigned int reserved_0      :8 ; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg2_11_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg2_11 : public vp::reg_128
        {
        public:
            inline void dcr_set(uint128_t value);
            inline uint128_t dcr_get();
            inline void bcr_set(uint128_t value);
            inline uint128_t bcr_get();
            inline void dynamic_addr_set(uint128_t value);
            inline uint128_t dynamic_addr_get();
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|

.. _i3c_Device_Char_Table_Reg3_11:

Device_Char_Table_Reg3_11
"""""""""""""""""""""""""

BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.

.. table:: 

    +-----+---+----------+------------------+
    |Bit #|R/W|   Name   |   Description    |
    +=====+===+==========+==================+
    |31:0 |R/W|RESERVED_0|Reserved/Not used.|
    +-----+---+----------+------------------+

Generated headers
"""""""""""""""""


.. toggle-header::
    :header: *Register map C offsets*

    .. code-block:: c

        
                // BCR, DCR & PID Values of the slave11 during the Dynamic address assignment command.
                #define I3C_DEVICE_CHAR_TABLE_REG3_11_OFFSET     0x2bc

.. toggle-header::
    :header: *Register accessors*

    .. code-block:: c


        static inline uint32_t i3c_device_char_table_reg3_11_get(uint32_t base);
        static inline void i3c_device_char_table_reg3_11_set(uint32_t base, uint32_t value);

.. toggle-header::
    :header: *Register fields defines*

    .. code-block:: c

        
        // Reserved/Not used. (access: R/W)
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_BIT                 0
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_WIDTH               32
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_MASK                0xffffffff
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_RESET               0x0

.. toggle-header::
    :header: *Register fields macros*

    .. code-block:: c

        
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_GET(value) (GAP_BEXTRACTU((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_GETS(value) (GAP_BEXTRACT((value),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0_SET(value,field) (GAP_BINSERT((value),(field),32,0))
        #define I3C_DEVICE_CHAR_TABLE_REG3_11_RESERVED_0(val)      ((val) << 0)

.. toggle-header::
    :header: *Register fields structures*

    .. code-block:: c

        
        typedef union {
          struct {
            unsigned int reserved_0      :32; // Reserved/Not used.
          };
          unsigned int raw;
        } __attribute__((packed)) i3c_device_char_table_reg3_11_t;

.. toggle-header::
    :header: *GVSOC registers*

    .. code-block:: c

        
        class vp_i3c_device_char_table_reg3_11 : public vp::reg_128
        {
        public:
            inline void reserved_0_set(uint128_t value);
            inline uint128_t reserved_0_get();
        };

|
